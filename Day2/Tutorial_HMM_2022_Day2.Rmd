---
title: "Hidden Markov Models: Missing data and multiple data streams"
author: "Ron Togunov & Marie Auger-Méthé"
output:
  html_document:
    number_sections: true
    highlight: tango
editor_options:
  chunk_output_type: console
---

<!-- To be able to have continuous line numbers -->
<style>
body
  { counter-reset: source-line 0; }
pre.numberSource code
  { counter-reset: none; }
</style>


# Tutorial goals and set up

## Objectives

Our main objectives are to handle some of the common data problems encountered with marine fastloc GPS data and diving data, using a narwhal dataset provided by Dr. Marianne Marcoux. Specifically, we aim to address the following:

-   Irregular locations

-   Time gaps

-   Including diving data-streams

## Loading the required packages

First, we'll setup the workspace with required packages.
 
```{r import_libraries, message=FALSE, attr.source = ".numberLines"}
library(momentuHMM)
library(dplyr)
library(tidyr)
library(lubridate)
library(adehabitatLT)
library(sf)
library(tmap)
library(terra)
library(units)
library(stringr)
library(diveMove)
library(conicfit)
library(car)
library(mitools)
library(doFuture)
library(corrplot)  # Pearson's correlation matrix using cor()
library(data.table)
library(earthtide)
library(knitr)
```

Please also set working directory to "Day2" of the HMM workshop:

```{r, eval=FALSE, message=FALSE, attr.source = ".numberLines"}
setwd("Day2")
```

## Import data and initial data processing

For simplicity, we will also only look at the data for the month of August, 2017. 
```{r import_tracks, message=FALSE, attr.source = ".numberLines"}
tracks <- read.csv("data/tracks.csv") %>%
  mutate(time = ymd_hms(time)) # define time
```

The data we obtain is often quite messy with records missing information and other records duplicated. we can filter only records with complete location data using `!is.na(x) & !is.na(y)` and remove duplicate records (same time, location, and location class) using the the `lag` function from `dplyr` which will use the value from the previous row.
```{r remove_missing_or_duplicate_data, message = FALSE, attr.source = ".numberLines"}
tracks <- tracks %>% 
  # remove missing locations
  filter(!is.na(x) & !is.na(y),
         # remove identical records
         !(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)))
```

Next, we'll convert the data to a spatial dataset using the `sf` package and plot the data. First, we define the coordinate reference system of the original data (in this case WGS84, which is defined by the EPSG code `4326`). Next, we will project the data into NAD83(CSRS) UTM zone 21N (EPSG:2962), which will projected the coordinates in meter units with minimal distortion for this data set. 

```{r define_projection, message=FALSE, attr.source = ".numberLines"}
tracks_proj <- tracks %>%
  st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
  st_set_crs(4326) %>% # define CRS
  st_transform(2962) # reproject data to a UTM
```

For the first part of this tutorial, we'll use only the fastloc GPS data so we don't have to deal with location error.

```{r filter_gps_data, message=FALSE, attr.source = ".numberLines"}
# filter GPS locations only
tracks_gps <- tracks_proj %>% 
  filter(loc_class=="GPS")
```

We lose some data, particularly near the end of the tracks, but we will integrate ARGOS locations later in this tutorial.

Now, we can map the data using the `tmap` package to visualize what it looks like.

```{r plot_gps_data, message=FALSE, attr.source = ".numberLines"}
# plot GPS
tracks_gps %>% 
  group_by(ID) %>% 
  summarise(do_union = FALSE) %>% 
  st_cast("LINESTRING") %>% 
     tm_shape() +
   tm_lines(col = "ID", palette = "Dark2")
```


## Selecting a time interval for the HMM

The classic HMM assumes the observation data is in discrete time and that there is no missing data in the predictor variables. There are two key decisions we must make, the temporal resolution to use, and how to address data gaps. The desired resolution depends predominantly on the biological question you are asking as different behaviours and biological processes occur at different spatial and temporal scales (e.g. seasonal migration, daily movement between foraging and resting grounds, and fine scale foraging decisions). Generally, higher resolution data is preferred as it has more information, however it is possible to have too-high of a resolution wherein information from fine-scale variability drowns out the signal from coarse-scale patterns of interest (e.g., seasonal migration). In this case, we will be linking the movement data with high resolution (75 s) dive data to look at finer-scale behaviours (on the order of a few hours). My rule of thumb, is that you want 3-50 data points per behaviour. For behaviours spanning several hours, that roughly corresponds to a desired resolution between 2 min and 60 min.

First, let's calculate the time difference between successive records using `difftime` and `lead` (compares current row to following row). For the last record of each individual (i.e., when `ID != lead(ID)`), we will set to `NA`.
```{r calc_dt, attr.source = ".numberLines"}
# Calculate time difference between locations
tracks_gps <- tracks_gps %>%
  mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
    difftime(lead(time), time, units = "mins"), NA
  )) # calculate time difference
```

Let's see what resolutions may be possible in the data by looking at the most frequent time gaps.
```{r calc_track_dt, attr.source = ".numberLines"}
# Visualize time differences
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
# Zoom in on short intervals
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
# identify the most frequent dt
tracks_gps %>% 
  {table(.$dt)} %>% 
  sort(decreasing = TRUE) %>% 
  head()
```

We see that the most frequent time gap is 10 min, followed by 11, 12, 22, 9, and 13 min. We also see the majority of the gaps are < 60 min, however some are in excess of 600 min. Because HMMs assume there are no missing records, finer resolutions will more gaps that would need to be interpolated. Frequent and large data gaps can be difficult to handle, especially as the number of missing data points approaches or exceeds the existing data; we really want to avoid this. Let's examine the potential data structure at different resolutions for the different animals.

We first create a function that can approximates the proportion of missing locations we would have for a given resolution.

```{r proportion_NA_fx, attr.source = ".numberLines"}
# Make function to estimate proportion of missing location 
p_na <- function(time, n_loc, res) {
  time <- round_date(time, paste(res,"min")) # round to nearest resolution
  time <- na.omit(time[time != lead(time)]) # remove duplicate time
  # calculate maximum number of locations          
  max_n_loc <- length(seq(time[1], tail(time, 1) + res*60, 
                          by = as.difftime(res, units = "mins")))
  n_NA <- max_n_loc - (length(time)+1)
  n_NA / max_n_loc
}
```

We can now use this function to look at the proportion of NAs we would get with 1, 2, 5, 10, and 20 min resolution.

```{r track_resolution_proportion_NA, attr.source = ".numberLines"}
# summarise track dt
tracks_gps %>% 
  st_drop_geometry() %>% 
  group_by(ID) %>% 
  summarise(p_NA_10m = p_na(time, n_loc, 10),  # 10 min 
            p_NA_20m = p_na(time, n_loc, 20),  # 20 min 
            p_NA_30m = p_na(time, n_loc, 30),  # 30 min 
            p_NA_60m = p_na(time, n_loc, 60))  # 60 min 
```

Here we see that the 10 min interval, around 50% of the locations would be missing. This is the limit that I would be comfortable at, since at finer resolutions, simulated data would outweigh real data, and may bias the results. Very large data gaps that contribute to much of the missing locations can be excluded from the analysis, therefore, for this tutorial, I will use a 10 min resolution.

## Handling data gaps

There are several ways to deal with data gaps, and I will address four 
1. Interpolation (linear and statistical)
2. Voiding data gaps
3. Path segmentation
4. Multiple imputation

Convert tracks 
```{r convert_tracks_to_list, attr.source = ".numberLines"}
# convert tracks back to data.frame with xy coordinates
tracks_gps_ls <- tracks_gps %>% 
  mutate(x = st_coordinates(tracks_gps)[,"X"],  
         y = st_coordinates(tracks_gps)[,"Y"]) %>%
  st_drop_geometry() %>% 
    split(.,.$ID)  # split into list
```


### Approach 1. Interpolation

#### Linear interpolation
For large datasets with few and small gaps, the simplest approach to use linear interpolation. First, let's identify the most likely minute we have data.
```{r identify_most_freq_dt, attr.source = ".numberLines"}
# which minute has the most data
tracks_gps %>% 
  st_drop_geometry() %>%  # convert back to data.frame
  group_by(ID) %>% 
  summarise(minute = str_sub(minute(time), -1)) %>% 
  table()
```

It looks like for all three tracks, the most amount of locations fall on 0 min  (i.e., 10, 20, 30, 40, 50, or 60 min). Next, for each track, we will create a vector of times in which to estimate locations.

```{r linear_interpolation_prep, attr.source = ".numberLines"}
# create full time series on which to estimate locations rounded to the nearest 10 min
tracks_gps_ls_time <- tracks_gps %>% 
  st_drop_geometry() %>%  # convert to data.frame
  group_by(ID) %>%
  summarise(time = seq(round_date(first(time), "10 min"), 
                       round_date(last(time), "10 min"),
                       by = 60*10)) %>% 
  split(.,.$ID)  # split into list
```

Now, we can interpolate the locations for each track.

```{r linear_interpolation, attr.source = ".numberLines"}
# function to create a data frame with approximated locations
approx_locs <- function(tracks, times){
  data.frame(ID = times$ID,
        time = times$time,
        x = approx(tracks$time, tracks$x,
                   xout = times$time)$y,
        y = approx(tracks$time, tracks$y,                               
                   xout = times$time)$y)
}

# Interpolate the location at the times from the sequence
tracks_gps_linear <- mapply(approx_locs, tracks_gps_ls, tracks_gps_ls_time,
                            SIMPLIFY = F) %>% 
  do.call("rbind", .)  # convert list of tracks back to a single data.frame

# remove row names added by rbind
rownames(tracks_gps_linear) <- NULL 

# plot locations
plot(tracks_gps_linear$x, tracks_gps_linear$y, pch = 20, col = "red", xlab = "x", ylab = "y", asp = 1)
points(st_coordinates(tracks_gps)[,"X"], st_coordinates(tracks_gps)[,"Y"], pch = 20)
```

Looks like it works. Let's try fitting an HMM to this. First, lets prepare the data using `prepData` and plot the data to estimate starting parameters.

```{r linear_HMM_prep, attr.source = ".numberLines", cache=T}
prep_gps_linear <- prepData(tracks_gps_linear, type = "UTM")

plot(prep_gps_linear, ask = FALSE)
```
Note how you can see the sections where we linearly interpolated locations as a horizontal segment in step-length

```{r linear_HMM_starting_pars, attr.source = ".numberLines"}
# define distribution to use for each data stream
dist <- list(step = "gamma", angle = "vm")

# Setting up the starting values
mu0 <- c(50, 500) # Mean step length
sigma0 <- mu0 # Sd of the step length
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)
# combine starting parameters 
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)

```

Ok, were are ready. Let's fit the HMM

```{r linear_HMM_fitHMM, message=FALSE, attr.source = ".numberLines", cache=TRUE}
set.seed(1)
# Fit a 2 state HMM
HMM_gps_linear <- fitHMM(prep_gps_linear, nbState = 2, dist = dist, Par0 = Par0)

plot(HMM_gps_linear, ask = FALSE)
plotPR(HMM_gps_linear)
```

The plotted states look relatively ok, however there is quite a weird flat section in the QQ-plot of the turning angle. In data with large linearly-interpolated gaps, the model often represents the original dynamic data as one state, and defines the straight interpolated segments with a second state. This is a common problem when data gaps are frequent or large such that the information in the interpolated data outweighs the signal from the original observations. Generally, I would only use linear interpolation when data gaps are small (< 3 locations) or relatively infrequent (< 20 \% of the modelled locations). In our data, some gaps are > 5 hours (30 locations) and > 50\% of the modelled locations are interpolated. So we need to use another approach.The flat section in the QQ-plot around 0 emerges because the model overestimates the values just below the middle quantile (in our case, $0^\circ$) and just above the middle quantile. In other words, our model is not capturing the large amount of turning angles really close to $0^\circ$ (this may be considered a good thing in our case since we know these are linearly interpolated).

#### Statistical interpolation {#stat_int}
A slightly better way to interpolate locations is to fit a continuous-time correlated random walk (CTCRW) model to the data and predict the most likely locations. `momentuHMM` contains wrapper functions to interpolate missing locations by fitting a CTCRW to the data based on the `crawl` package by Devin Johnson and Josh London. There are many options to fit the CTCRW model, and a detailed tutorial for analysis with `crawl` is available here: propperly  <https://jmlondon.github.io/crawl-workshop/crawl-practical.html>. Let's try to fit the most basic model using the wrapper function `crawlWrap`.

```{r crawl_10_min_gps, attr.source = ".numberLines", cache=TRUE}
set.seed(5) # crawl can fail to fit periodically, so I recommend always setting a seed 

# fit crawl
crw_gps_10 <- crawlWrap(obsData = tracks_gps, timeStep = "10 mins")
# view that all parameters were propperly estimated 
crw_gps_10$crwFits %>% 
  lapply(function(x){
    x[c("par","se","ci")] %>%  # get estimated values 
    unlist() %>%  # unlist
      is.nan() %>%  # identify values that failed to estimate
      sum() == 0 # count failed estimates and ensure there are 0
  }) 
# plot fit tracks
plot(crw_gps_10, ask = FALSE)
```

Notice how the predicted tracks do not make perfectly straight lines through missing sections (particularly noticeable in T172062). Next, we will extract the predicted locations and add them to the observed data.

```{r crawl_predict_10_min, attr.source = ".numberLines"}
# filter predicted locations
tracks_gps_crw <- data.frame(crw_gps_10$crwPredict) %>% 
  filter(locType == "p") %>% 
  dplyr::select(mu.x, mu.y, time,
         ID) %>% 
  dplyr::rename(x = "mu.x", y = "mu.y")
```

Now, let's try to fit the same HMM as before on this data using the same starting parameters.

```{r crawl_HMM_fitHMM, message=FALSE, attr.source = ".numberLines", cache=TRUE}
set.seed(1)
# prep data 
prep_gps_crw <- prepData(tracks_gps_crw, type = "UTM")

# Setting up the starting values
mu0 <- c(50, 500) # Mean step length
sigma0 <- c(50, 500) # Sd of the step length
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)
# Fit a 2 state HMM
HMM_gps_crw <- fitHMM(prep_gps_crw, nbState = 2, dist = dist, Par0 = Par0)

plot(HMM_gps_crw, ask = FALSE)
```

That's looking much better. It looks like state 1 represents a low-speed, high tortuosity resident state, while state 2 represents higher-speed, low tortuosity travelling state. 

In many instances, this model may be sufficient. However, the significant proportion of interpolated locations used to fit the model is likely to affect our results. For example, the large interpolated gaps are still relatively straightened out and a very consistent speed, and may skew the definition of state 2 in particular. Simply interpreting the results with this issue in mind can be adequate when we only have few interpolated locations. Below, we will explore more formal ways to address this problem, which can be particularly useful when we have very large numbers of interpolated locations.

### Approach 2. Voiding data gaps {#void_gaps}

One strategy to address large data gaps is to void the data streams (i.e., step length and turning angle) during moderate/large interpolated gaps where we expect that the estimated movement has is largely independent of the observed data before or after the gap. The maximum size of a gap to allow depends on the frequency of the missing data, frequency of locations, study species, and behaviours of interest. In this case, I will void the data streams from locations predicting in gaps $>60$ min. First, we will identify which steps need to be voided, then we will prepare the data and void the estimated `step` and `angle` data streams. We will do this again later in the tutorial, so we will wrap it into a function called `prepData_NAGaps`.

```{r id_void_gaps, attr.source = ".numberLines"}
# define function to replace step and turn angle of large gaps with NA
NA_gaps <- function(tracks, times){
  # rows where location is within a large gap
  rows <- which(
    rowSums(apply(times, 1, function(X, tracks){
      dplyr::between(tracks, 
                     as.POSIXct(X[1], tz = "UTC"),
                     as.POSIXct(X[2], tz = "UTC"))
    }, tracks$time))==1)
  tracks$step[rows] <- NA
  tracks$angle[rows] <- NA
  return(tracks)
}
# define function to identify and nullify gaps
prepData_NAGaps <- function(track_list, tracks_crw, res, max_gap, ...){
  # for each ID, identify which rows have gaps >= max_gap 
  gaps_ls_rows <- lapply(track_list, function(x){
    which(difftime(lead(x$time), x$time, units = "mins") >= max_gap)
  })
  
  # create sequence of times for each track from gaps >= 60 min
  gap_ls <- mapply(FUN = function(track, gaps){
    # identify start and end date of each gap
    gaps_ls_srt_end <- list(start = ceiling_date(track$time[gaps], paste(res, "min")),
                            end = floor_date(track$time[gaps+1], paste(res, "min")))
    # combine into single vector for each track
    data.frame(start = gaps_ls_srt_end$start, end = gaps_ls_srt_end$end)
  },
  track_list, gaps_ls_rows, SIMPLIFY = F)
  
  # prep data and list by ID
  prep_tracks <- prepData(tracks_crw, ...) %>% 
    {split(., .$ID)}
  
  # Interpolate the location at the times from the sequence
  mapply(FUN = NA_gaps, prep_tracks, gap_ls,
         SIMPLIFY = F) %>% 
    do.call("rbind", .) # convert list of tracks back to a single data.frame
}
  
prep_tracks_gps_crw_NAgaps <- prepData_NAGaps(tracks_gps_ls, tracks_gps_crw, 10, 60, type = "UTM")
```

Now, let's try to fit the same HMM as above to this data with large gaps voided. 

```{r voided_crawl_HMM_fitHMM, message=FALSE, attr.source = ".numberLines", cache=TRUE}
set.seed(1)
# Setting up the starting values
mu0 <- c(50, 500) # Mean step length
sigma0 <- c(50, 500) # Sd of the step length
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)

# Fit a 2 state HMM
HMM_gps_crw_NAgaps <- fitHMM(prep_tracks_gps_crw_NAgaps, nbState = 2, dist = dist, Par0 = Par0)

plot(HMM_gps_crw_NAgaps, ask = FALSE)
```

Visually, the difference is subtle.

```{r, attr.source = ".numberLines"}
HMM_gps_crw$mle[c("step", "angle")]
HMM_gps_crw_NAgaps$mle[c("step", "angle")]
```

However, the estimated parameters are quite different whether you account for the large gaps in data. When you void large gaps, the mean step length for both states is higher, and the turn angle concentration parameters is lower for both states (i.e., more tortuous). The fact that the parameters change for both states, suggests that the large gaps skewed the parameterisation of both states.

### Approach 3. Path segmentation

Another strategy to deal with larger gaps is to segment the tracks with a new individual ID. This may be particularly appropriate for gaps where we may reasonably expect that the the underlying states are effectively independent of one another. Specifically, we may ask, over what period of time does the behaviour of the animal affect the subsequent behaviour. In this case, we may expect that the behaviour of a narwhal depends on the behaviour over the proceeding several hours, however is independent after 24 hours. We can split the tracks for gaps larger than a predetermined threshold by iterating the ID column. We will not implement this approach in this tutorial, however, it can be done using the following code:

```{r track_segmentation, attr.source = ".numberLines"}
gap_thresh <- 3*60 # in hours (3h for illustration)
# gaps no more than 6h per segment
new_ID <- (tracks_gps$dt > gap_thresh | tracks_gps$ID != lag(tracks_gps$ID)) %>%  # if dif.time > gap_thresh or new ID
  replace_na(TRUE) %>%  # replace first NA with ID = 1
  cumsum() %>%  # iterate ID 
  paste(tracks_gps$ID, ., sep = "_")
# then smaller gaps <= gap_thresh can be interpolated with crawlWrap
```
### Approach 4. Multiple imputation
The last approach to estimate missing locations and regularise the data is multiple imputation (Hooten et al. 2017; McClintock 2017). Multiple imputation works by first fitting a CTCRW model to the original data, second, drawing (i.e., simulating) a number of realisations of the position process based on the CTCRW model, third, fitting HMMs to each of the simulated realisations, and finally, pooling the estimated parameters. 

`momentuHMM` has several functions to implement multiple imputation. The function `MIfitHMMW` can be used both to simulate realisations of a fitted CTCRW and fit HMMs to each one. The number of simulations is specified with `nSims`. We can simulate realisations without fitting HMMs by setting `fit = FALSE`. Here, let's use the CTCRW model that we fit in section \@ref(stat_int) to simulate 4 tracks using `MIfitHMMW` and plot them over the original track.
```{r MI_sim_10min_GPS, attr.source = ".numberLines", cache = TRUE}
set.seed(1)
# simulate 4 realisations of the 10 min GPS CTCRW model
MI_sim_gps <- MIfitHMM(crw_gps_10, nSims = 4, fit = FALSE)

# plot locations for first narwhal
# filter first ID from original data
track <- tracks_gps %>% 
  mutate(x = st_coordinates(tracks_gps)[,"X"], 
         y = st_coordinates(tracks_gps)[,"Y"]) %>% 
  filter(ID == "T172062")
# filter first ID for each simulation
sim_tracks <- lapply(MI_sim_gps$miData, function(x){
  filter(x, ID == "T172062")})

# plot original track for first narwhal
plot(track$x, track$y, col = "red", xlab = "x", ylab = "y", asp = 1, type = 'l')
# plot each simulated track
mute <- mapply(function(data, col){
  points(y~x, data = data, col = col, type = 'l')
  }, data = sim_tracks, col = list("cadetblue1", "cadetblue2", "cadetblue3", "cadetblue4"), SIMPLIFY = FALSE)
```
Notice how in some areas the different simulations have generally good agreement in the likely location during gaps, while in others they diverge. Multiple imputation can be particularly powerful if we want to incorporate environmental variables, as spatially explicit variables can be extracted for each simulated track to sample the most likely conditions encountered by the animal. 

As you can imagine, fitting multiple imputations can take quite a bit of time. We can speed up the computation by simulating/fitting each track in parallel using the `ncores` argument. We can identify the number of cores our PC has using `parallel::detectCores()`.
```{r count_ncores, attr.source = ".numberLines"}
# count number of available cores and use 60% of available cores
ncores <- parallel::detectCores()
ncores <- round(ncores*0.6)
```

Next, let's simulate 12 realisations of the CTCRW and fit HMMs to each in parallel. 
```{r fit_10min_GPS_MI, attr.source = ".numberLines", cache=TRUE}

set.seed(1)
# fit multiple imputation HMM to the 10 min GPS crawl model
HMM_gps_MI <- MIfitHMM(crw_gps_10, nSims = 12, ncores = ncores,
                       nbStates = 2, dist = dist, Par0 = Par0, fit = TRUE)
# plot MI fits
plot(HMM_gps_MI, ask = F)
```
When plotting multiple imputed data, `momentuHMM`will include estimated location error ellipses in the plots.

To better illustrate the effectiveness of multiple imputation in recovering states we can randomly filter locations then compare state recovery from a single most likely imputed track to states from multiple-imputed tracks. First, let's randomly filter 98 locations for each narwhal (in addition to the first or last locations so that the path length is the same),
```{r sample_100_locs, attr.source = ".numberLines"}
set.seed(1)
# number of rows for each narwhal
tracks_gps_sub <- tracks_gps_ls %>% 
  lapply(function(x){
    # number of rows for each narwhal
    nrow <- nrow(x)
    # rows to sample sorted chronologically
    sub <- sort(c(1, nrow,  # first, last,
                  sample(2:(nrow-1), 98)))  # random 98 from the middle
    # sample selection
    x[sub,]
  }) %>% 
  # convert back to a single data frame
  do.call(rbind, .)
```

Next, lets fit a CTCRW to the sampled data (100 locs pre narwhal).
```{r sample_crawl, attr.source = ".numberLines", cache=TRUE}
set.seed(3)
# fit crawl
crw_gps_sub <- crawlWrap(obsData = tracks_gps_sub, timeStep = "10 mins")
# check that all parameters were estimated 
crw_gps_sub$crwFits %>% 
  lapply(function(x){
    x[c("par","se","ci")] %>%  # get estimated values 
    unlist() %>%  # unlist
      is.nan() %>%  # identify values that failed to estimate
      sum() == 0 # count failed estimates and ensure there are 0
  })
```

Next, we can predict the most likely track using `prepData` on the CTCRW model, fit an HMM to this data using `fitHMM`, and calculate the proportion of decoded states that match the states predicted from the full data set.
```{r sample_prep_fit, attr.source = ".numberLines", cache=TRUE}
# prep data
prep_gps_sub <- prepData(data = crw_gps_sub)

# Fit a 2 state HMM
set.seed(1)
HMM_gps_sub <- fitHMM(prep_gps_sub, nbState = 2, dist = dist, Par0 = Par0)

# compare states
sum(viterbi(HMM_gps_sub) ==
      viterbi(HMM_gps_crw))/nrow(HMM_gps_sub$data)
```
In this case, it appears that there is only a $49\%$ overlap between the single imputation based on `r nrow(tracks_gps_sub)` sampled data points compared to HMM based on the `r nrow(tracks_gps)` data points in the original data. Given that there are only two states, $49\%$ is about what we would expect the model to estimate by random chance at all.

As a comparison, let`s generate and fit 100 simulated tracks from the CTCRW fit to the sampled `r nrow(tracks_gps_sub)` locations, then compare the states. With 100 simulations, the benefits of parallel processing become very apparent.
```{r sample_MIfit, attr.source = ".numberLines", cache=TRUE}
set.seed(1)
# fit MI HMM
HMM_gps_sub_MI <- MIfitHMM(crw_gps_sub, nSims = 100, ncores = ncores,
                       nbStates = 2, dist = dist, Par0 = Par0, fit = T)

# pool simulation results
MIpool_gps_sub <- MIpool(HMM_gps_sub_MI[[2]]) 
plot(MIpool_gps_sub)

# compare states
sum(MIpool_gps_sub$Par$states == 
      viterbi(HMM_gps_crw))/nrow(prep_gps_crw) 
```
Using multiple imputation, we see that the state overlap increases from $49\%$ to $74\%$. on your own time, try increasing the number of simulations even more to see how the predictions change. 

#### Multiple imputation - preventing label switching
One issue that may come up when implementing multiple imputation is "label switching". Label switching is when two or more HMMs converge effectively the same (i.e., all parameter estimates are the same), but the assign a different state to the set of parameters. For example, one HMM defines state 1 as slow and state 2 as fast, while a second HMM defines state 1 as fast and state 2 as slow. This can occur if the states have similar parameters, if the initial starting parameters are far from the optimum, or there likelihood surface is noisy or complex. The key issue that may arise from label switching, is when pooling the results from multiple imputations, the summarized parameters or estimated states would be incorrect. The best strategy to preventing state label switching is to use pseudo-design matrices (pseudo-DM) in tandem with the `workBounds` argument when repeatedly fitting the same HMM. Pseudo-DMs operate by mapping working parameters (columns) to natural parameters  (rows). Each distribution parameter (e.g., step length mean and sd) for each state must have precisely one corresponding row in the DM. For example, a two state HMM, with one data stream (e.g., step length) that is defined by two parameters (e.g., mean and sd) must 4 rows. If the parameters for each state are completely independent, the pseudo DM would look as follows:
```{r DM_independent}
stepDM <- matrix(c(1,0,0,0, 
                   0,1,0,0, 
                   0,0,1,0, 
                   0,0,0,1), 
                 nrow = 4, ncol = 4,
                 byrow = TRUE)
rownames(stepDM) <- c("mu_1","mu_2","sd_1","sd_2") 
colnames(stepDM) <- c("mu_1_i","mu_2_i", "sd_1_i","sd_2_i")
stepDM
```
Note: naming the rows and column is completely optional. Is addition, when DMs are used, the starting parameters must be specified on the working scale $(-\infty, \infty)$. If, for example, we want both states to share the same mean parameter, the DM would look as follows:
```{r DM_share_mu}
stepDM <- matrix(c(1,0,0,
                   1,0,0, 
                   0,1,0, 
                   0,0,1),
                 nrow = 4, ncol = 3,
                 byrow = TRUE)
rownames(stepDM) <- c("mu_1","mu_2","sd_1","sd_2") 
colnames(stepDM) <- c("mu_1.2_i", "sd_1_i","sd_2_i")
stepDM
```
In this case, the model would estimate 3 parameters: `mu_1.2_i`, `sd_1_i`, and `sd_2_i`, where `mu_1.2_i` would represent the mean parameter for both state 1 and state 2. 

Notably, we can constrain the natural parameters of one state to be greater or less than another state by using DMs in tandem with `workBounds`, which allows us to specify constraints on working parameters. For example, if we want state 2 to be faster than state 1, we can define the pseudo-DM and `workBounds` as follows:
```{r DM_constraint, attr.source = ".numberLines"}
# step DM
stepDM <- matrix(c(1,0,0,0, 
                   1,1,0,0,  # Notice the two 1s
                   0,0,1,0, 
                   0,0,0,1), 
                 nrow = 4, ncol = 4,
                 byrow = TRUE)
rownames(stepDM) <- c("mu_1","mu_2","sd_1","sd_2") 
colnames(stepDM) <- c("b1","b2", "b3","b4")
# work bound
stepWB <- matrix(c(-Inf, 0,  -Inf, -Inf,   # lower bounds
                    Inf, Inf, Inf,  Inf),  # upper bounds
                 nrow = ncol(stepDM), ncol = 2,
                 dimnames = list(colnames(stepDM),
                                 c("lower","upper")))
# view
stepDM; stepWB
```
In this case, $\beta_1$ would represent the mean step length parameter for state 1, and the mean step length for state 2 would be represented by the sum of $\beta_1$ and $\beta_2$, where $\beta_2$ would be transformed to be >0. Specifically, $\mu_1^{(l)} = exp(\beta_1)$ and $\mu_2^{(l)} = \exp(\beta_1 + \exp(\beta_2))$. Note: without specifying `workBounds`, $\beta_2$ would not be transformed, and state 2 could be slower than state 1 (i.e., if $\beta_2<0$, $\exp(\beta_1) > \exp(\beta_1 + \beta_2)$). 
For completeness, the following code integrates pseudo-DM and working constrains in an HMM fit multiple times using a multiple-imputation HMM (we will not run this).
```{r DM_constraint_fit, eval=FALSE}
# create named lists for DM and workBounds
DM <- list(step = stepDM)
WB <- list(step = stepWB)
# convert starting parameters for step length to the working scale
Par0_WB <- list(step = log(Par0$step),
                  angle = Par0$angle)
Par0_WB$step[2] <- 0
# fit MI HMM
HMM_gps_sub_MI_WB <- MIfitHMM(crw_gps_sub, nSims = 10, ncores = ncores, 
                              nbStates = 2, dist = dist, fit = T,
                              Par0 = Par0_WB, DM = DM, workBounds = WB)
```
Note: because we specify a DM for step length, we must log-transform the starting parameters to the working scale.

## Integrating dive data

Let's import the dive data and explore it.

```{r import_depth_data, warning=FALSE, attr.source = ".numberLines"}
dives <- read.csv("data/dives.csv") %>% 
  mutate(time = ymd_hms(time)) %>% 
  filter(month(time) == 8, day(time) > 7,  day(time) <= 14)

head(dives)
table(dives$dt)
```

It appears as though there are relatively few gaps, however the gaps that exist are relatively long (> 60 mins). Therefore, I suggest that we should regularize the dive data and void large gaps.

```{r regularise_depth_data, warning=FALSE, attr.source = ".numberLines"}
# regularise data 
dives <- dives %>% 
  group_by(ID) %>%
  # regularise time series by 1.25 min
  summarise(time = seq(first(time), last(time), by = 1.25*60)) %>%
  # merge regularised time with original dive
  left_join(dives, by = c("ID", "time"))
```

Next, we have to summarise the time series into concrete data streams that can be modelled in the HMM. We can use the `diveMove` package to identify individual dives and calculate dive statistics. We must first convert the depth data to the `TDR` class for each whale. As we are working with multiple whales, we will use `lapply` to apply the `createTDR` to each whale -- we will also use `lapply` for most of `diveMove` functions.

```{r convert_depth_data_to_TDR, warning=FALSE, attr.source = ".numberLines"}
dives_ls <- split(dives, dives$ID) 
dive_TDR <- lapply(dives_ls, function(data){
  createTDR(time = data$time, depth = data$depth, dtime = 1.25*60, file = "data/dives.csv")
  })

# generate interactive plot
plotTDR(dive_TDR[[1]]) # note: try zooming in to part of the dive
```

Next, we must use the `calibrateDepth` to calibrate the depth data. This function identifies wet and dry periods (for animals that haul out), applies a zero-offset correction (ZOC), and identifies all dives in the record and their phases. ZOC can be done using either the `offset` or `filter` method. In this case, we will assume the depth data is accurate and does not require an offset. We should also specify `dive.thr`, which represents the threshold depth below which an underwater phase should be considered a dive -- in this case, we will set it at 8 m. There are many other optional parameters to identify dives that we will not get into in this tutorial (See `vignette("diveMove")` for details). 

<!-- MAM: add cache=TRUE to make the kniting faster. Note that sometimes you need to remove the files created, if you run into problems. -->

```{r calibrate_TDR, warning=FALSE, cache=TRUE, attr.source = ".numberLines"}
# calibrate TDR and identify dive phases
dive_TDR_calib <- lapply(X = dive_TDR, FUN = calibrateDepth, zoc.method = "offset", offset = 0, dive.thr = 8)

# interactive plot of calibrated DTR
plotTDR(dive_TDR_calib[[1]], surface = TRUE)
```

In the interactive plot, try zooming into one of the dives and hover mouse over plot to preview the phases identified by `calibrateDepth'. The phases identified correspond to descent (D), descent/bottom (DB), bottom (B), bottom/ascent (BA), ascent (A), and surface (X). We can plot a specific dives as follows:

```{r plot_TDR_calib_dives, attr.source = ".numberLines"}
plotTDR(dive_TDR_calib[[1]], diveNo = 1:300, surface = TRUE)
```

Now, we can calculate summary statistics for each dive using the function `diveStats`. There are many dive metrics that are estimated, and which ones to retain are species, data, and question specific. In this case, we will retain 8 from those calculated by `diveStats`: dive time, bottom time,  maximum depth, bottom distance (measure of "wiggling while at the bottom), post-dive duration.

```{r calc-summary_dive_stats, attr.source = ".numberLines", cache=T}
# calculate dive stats and add dive.id to each dive 
dive_sum <- lapply(dive_TDR_calib, function(data){
  mutate(diveStats(data, depth.deriv = FALSE), dive.id = row_number()) %>% 
    dplyr::select(dive.id, divetim, botttim, maxdep, bottdist, postdive.dur)}) # select variables of interest

# add dive.id with depth data to each depth record
dives_ls <- mapply(function(TDR, dives){
  mutate(TDR, dive.id = dives@dive.activity$dive.id)
  }, TDR = dives_ls, dives = dive_TDR_calib, SIMPLIFY = F)

# join TDR data with dive summary data
dives_ls <- mapply(function(TDR, dive_sum){
  left_join(TDR, dive_sum, by = "dive.id")
  }, TDR = dives_ls, dive_sum = dive_sum, SIMPLIFY = F)

# convert dive_ls back to a data.frame
dives_df <- do.call(rbind, dives_ls)
```

<!-- MAM: 75 sec is actually quite long. Is that something that is recommended? Update: from the next comment, it's because of the resolution. Please mention the resolution further up, when presenting the data, and refer back to it here. -->

Next, we will replace any bottom time of a valid dive (dive.id > 0) to 75 s, since at least some time must be spent at the bottom. Then, we will calculate one additional metric as a proxy for dive shape; the ratio of bottom time to dive time. Dives where $\leq20\%$ of the time is spent at the bottom represent V-shaped dives, U-shaped dives are represented when $>20$ and $\leq50\%$ is spent at the bottom, and square dives are represented when $>50\%$ of the time is spent at the bottom. 

```{r calc_percent_bottom, attr.source = ".numberLines"}
# replace NA bottom time of valid dives
dives_df$botttim[dives_df$dive.id > 0 & is.na(dives_df$botttim)] <- 75
# calculate proportion time at bottom
dives_df <- dives_df %>% 
  mutate(propbott = botttim/divetim)
# remove "dives" with no duration
dives_df <- dives_df %>% 
  filter(!(dive.id > 0 & is.na(divetim)))
```

The next issue is that the dive data is at a different temporal resolution (75 s) than the location data (10 min). There are two options to include both data streams in the same HMM. First, we can choose to implement a hierarchical HMM, however, this is more complicated, and  will be covered in tomorrow's tutorial. The second, which we will use here, is to summarise the depth/dive data to a 10 min resolution and include them as additional data streams with step length and turning angle. 

```{r summarise_dive_data_to_10 min, attr.source = ".numberLines"}
dives_sum <- dives_df %>% 
  # round time to same interval as location data
  mutate(time = floor_date(time, "10 min")) %>% 
  # group rows by time interval
  group_by(ID, time) %>% 
  # summarise data
  summarise(NA_t          = sum(is.na(depth))*1.25,
            surf_t        = sum(dive.id == 0)*1.25,
            mean_dep      = ifelse(NA_t == 10, NA, mean(na.rm = T, depth)),
            max_dep       = ifelse(NA_t == 10, NA, max(na.rm = T, depth)),
            dive_t        = ifelse(NA_t == 10, NA, sum(na.rm = T, divetim)),
            bott_t        = ifelse(dive_t < 5, NA, sum(na.rm = T, botttim)),
            prop_bott     = ifelse(dive_t < 5, NA, max(na.rm = T, propbott)),
            max_dive_dep  = ifelse(dive_t < 5, NA, max(na.rm = T, maxdep)),
            bott_dist     = ifelse(dive_t < 5, NA, max(na.rm = T, bottdist)),
            post_dive_dur = ifelse(dive_t < 5, NA, max(na.rm = T, postdive.dur))) %>% 
  # remove -Inf values (typically error)
  filter(!is.infinite(dive_t) & !is.infinite(bott_dist))

# preview
head(dives_sum)
```

<!-- MAM: this gives a lot of warnings! WHat is going on? -->

Note, we used 2 different `ifelse` statements. First, `ifelse(NA_t == 10, ...)` ensured that we only calculate mean and maximum depth for periods where we have at least 1.25 min of depth data. Second, `ifelse(surf_t > 5, ...)` ensured that we only calculate dive metrics when at least half of the 10 min interval is spent in a dive, otherwise the animal is assumed to be at the surface and its dive metric is `NA`.

Any of the eight variables can be used as data streams in the HMM, however, including too many would significantly increase the number of parameters to estimate, and consequently computation time. Therefore, we must select which variables to use, which there are different several approaches:
1. Variable can be selected using expert on the species behaviour and research question.
2. We preferably want to avoid variable with a lot of missing data. 
3. The data streams should exhibit variation and evidence of clustering or multi-modality that may be tied to the underlying behaviours. 
4. Data streams with no variation or conversely are very noisy contain little information on underlying behaviour.
5. We want to avoid variables that are overdispersed and which would be difficult to describe using a statistical distribution. 
6. Given that they are tied to autocorrelated behaviours, they too should exhibit some -- but not too much -- autocorrelation. 
7. One of HMM's key assumptions that the data stream are be independent of each other, therefore, we should avoid select highly co-linear data streams. 

Assuming all the variables are biologically relevant, let's look at structure in the data.
I will also add a subjective score based on the results (first number after `#` symbol).

<!-- MAM: break down this chunk and add explanations for each bits -->

```{r data_structure, attr.source = ".numberLines", cache=T}
vars <- c("mean_dep","max_dep","dive_t","bott_t","prop_bott",
          "max_dive_dep","bott_dist","post_dive_dur")
# First, missing data
dives_sum %>% 
  summarise(mean_dep      = sum(is.na(mean_dep)),      # 2
            max_dep       = sum(is.na(max_dep)),       # 2
            dive_t        = sum(is.na(dive_t)),        # 2
            bott_t        = sum(is.na(bott_t)),        # 1
            prop_bott     = sum(is.na(prop_bott)),     # 1
            max_dive_dep  = sum(is.na(max_dive_dep)),  # 1
            bott_dist     = sum(is.na(bott_dist)),     # 1
            post_dive_dur = sum(is.na(post_dive_dur))) # 1

# Second, evidence of multi-modality, balanced variation, and no over-dispersion
# as the dive variables are zero-bound, applying a log transformation makes it easier to see structure in the distirbution 
# dives_sum %>% 
#   ungroup() %>% 
#   dplyr::select(vars) %>% 
#   apply(2, hist, 100)
hist(log(dives_sum$mean_dep), 100)      # 2 good structure, high dispersion
hist(log(dives_sum$max_dep), 100)       # 3 great structure, moderate dispersion
hist(log(dives_sum$dive_t), 100)        # 1 little structure, fragmented distribution
hist(log(dives_sum$bott_t), 100)        # 0 little structure, fragmented distribution
hist(logit(dives_sum$prop_bott), 100)   # 0 no structure, fragmented distribution
hist(log(dives_sum$max_dive_dep), 100)  # 2 good structure, low dispersion
hist(log(dives_sum$bott_dist), 100)     # 2 moderate structure, high dispersion
hist(log(dives_sum$post_dive_dur), 100) # 0 little structure, high dispersion

# Third, balanced autocorrelation
dives_sum_filter <- filter(dives_sum, ID == "T172062")
acf(dives_sum_filter$mean_dep, na.action = na.pass)       # 1 ACF~8 some variability
acf(dives_sum_filter$max_dep, na.action = na.pass)        # 2 ACF~8 gradual decline
acf(dives_sum_filter$dive_t, na.action = na.pass)         # 2 ACF~7 gradual decline
acf(dives_sum_filter$bott_t, na.action = na.pass)         # 0 ACF~3
acf(dives_sum_filter$prop_bott, na.action = na.pass)      # 0 ACF~2
acf(dives_sum_filter$max_dive_dep, na.action = na.pass)   # 1 gradual but high ACF~22
acf(dives_sum_filter$bott_dist, na.action = na.pass)      # 1 low ACF~4
acf(dives_sum_filter$post_dive_dur, na.action = na.pass)  # 0 low ACF~1

# subjective score
data.frame(var = c("mean_dep", "max_dep", "dive_t", "bott_t", "prop_bott", 
                   "max_dive_dep", "bott_dist", "post_dive_dur"),
           score = c(5, 6, 5, 1, 
                     1, 4, 4, 1))

```

From my subjective interpretation of these outputs, I think the five most promising variables to include are maximum depth, dive time, mean depth, maximum dive depth, and bottom distribution. Next, let's merge the dive data streams the location data.

```{r merge_track_and_dive_data, attr.source = ".numberLines"}
tracks_dives <- left_join(prep_tracks_gps_crw_NAgaps, 
                          dives_sum[,c("ID", "time", "max_dep", "dive_t", 
                                       "mean_dep", "max_dive_dep", "bott_dist")], 
                          by = c("ID", "time"))
```

Now, we must check for co-linearity between the data streams to select 1--3 to use in the HMM. We can check co-linearity using the Pearson's correlation matrix.

```{r dive_co_linearity, attr.source = ".numberLines"}
# calculate and plot check Paerson's correlation matrix
tracks_dives[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", 
             "bott_dist", "step", "angle")] %>% 
  na.omit() %>%
  cor() %>% 
  corrplot(method="number")
```

`step` and `angle` seem quit independent from all variables as does `bott_dist`. Unfortunately, there is quite high correlation between the first four dive data streams, se we will have to select which to use. `dive_t` and `mean_dep` have the lowest correlation with `bott_dist` and `step`, however `max_dep` had the highest subjective score. For the purposes of this tutorial, I will use `max_dep` and `bott_dist`. 

<!-- MAM: HMM assumes that the response variables are conditionally independent base on the state. You may want to mention that. Some of that correlation could be explained by the state, -->

To get starting parameters, we can fit an HMM to each one independently. We will use the gamma distribution for both and for now will use the same starting parameters.

```{r prep_dive_data_and_independent_HMMs, message=FALSE, attr.source = ".numberLines", cache=TRUE}
# identify whether there is 0 data
tracks_dives %>% 
  summarise(max_dep = sum(max_dep == 0, na.rm = T), 
            bott_dist = sum(bott_dist == 0, na.rm = T)) 
# therefore, we need to include zero-mass parameters for bott_dist

# starting parameters (will use same ones for both for now)
mu0 <- c(130, 180)  # mean
sigma0 <- c(60, 90)  # sd
zm <- c(0.1, 0.1)  # zero mass, where applicable

# fit dive-only HMMs
set.seed(1)
HMM_max_dep <- fitHMM(tracks_dives, nbStates = 2, dist = list(max_dep = "gamma"), 
                      Par0 = list(max_dep = c(mu0, sigma0)))
HMM_bott_dist <- fitHMM(tracks_dives, nbStates = 2, dist = list(bott_dist = "gamma"), 
                        Par0 = list(bott_dist = c(mu0, sigma0, zm)))
```

Next, we can integrate these into one HMM together with step length and turning angle. When we specify the starting parameters, we want to think about how the states may look. For example, we might expect one resident state with slower movement, lower angular concentration, deeper dives, and greater at-depth variability. The second state may be travel, with faster movement, greater angular concentration, shallower dives, and less  at-depth variability.

```{r prep_data_for_dive_move_HMM, attr.source = ".numberLines"}
# prep model
stateNames = c("resident", "travel")
nbStates = length(stateNames)
dist = list(step = "gamma", angle = "vm", 
            max_dep = "gamma", bott_dist =  "gamma")

# Starting Pars 
  # view Pars from previous HMMs
  getPar(HMM_gps_crw_NAgaps)$Par  # state 1 ~ resident, state 2 ~ travel
  getPar(HMM_max_dep)$Par  # state 1 ~ travel, state 2 ~ resident
  getPar(HMM_bott_dist)$Par  # state 1 ~ travel, state 2 ~ resident
  # therefore must switch parameter estimates in HMM_max_dep & HMM_bott_dist
  
  # combine starting Pars 
  step0 <- getPar(HMM_gps_crw_NAgaps)$Par$step
  angle0 <- getPar(HMM_gps_crw_NAgaps)$Par$angle
  max_dep0 <- c(getPar(HMM_max_dep)$Par$max_dep[c(2,1)],  # mu1, mu2
                getPar(HMM_max_dep)$Par$max_dep[c(4,3)])  # sd1, sd2
  bott_dist0 <- c(getPar(HMM_bott_dist)$Par$bott_dist[c(2,1)],  # mu1, mu2
                  getPar(HMM_bott_dist)$Par$bott_dist[c(4,3)],  # sd1, sd2
                  getPar(HMM_bott_dist)$Par$bott_dist[c(6,5)])  # zm1, zm2
  Par0 <- list(step = step0, angle = angle0, max_dep = max_dep0, bott_dist = bott_dist0)
```

Now, we can fit the HMM with movement and dive variables.
```{r fit_move_dive_HMM, message=FALSE, cache=TRUE, attr.source = ".numberLines"}
set.seed(1)
HMM_move_dive <- fitHMM(tracks_dives, nbStates=nbStates, stateNames=stateNames, dist=dist, Par0=Par0)
```

Let's see what it looks like.
```{r view_HMM_move_dive, attr.source = ".numberLines", cache = T}
plot(HMM_move_dive, breaks = 100, ask = FALSE)
plotPR(HMM_move_dive)
```

The tracks look interesting. But there are some issues in the pseudo residuals.

Looking at the QQ plots the model appears to:
- overestimate the number of fast movement steps
- underestimating higher turning angles
- underestimate shallow dives and over estimate deep dives
- really wonky description of `bott_dist`
The autocorrelation functions suggest there is remnant autocorrelation in `step` and `max_dep` that are not well described by the model. Together, this information suggests that there may be additional states that are not represented. Let's try to add one more state with an intermediate speed, lower angle concentration, and shallow dives.

```{r 3_state_dive_and_move_HMM, message=FALSE, cache=TRUE, attr.source = ".numberLines"}
# define states
stateNames <- c("resident", "travel", "search")
nbStates <- length(stateNames)

# Starting Pars 
  # get Pars from last HMM_move_dive HMM
  Pars <- getPar(HMM_move_dive)$Par 

  # combine starting Pars 
  step0 <- c(Pars$step[c(1,2)], mean(Pars$step[c(1,2)]),  # mu
             Pars$step[c(3,4)], mean(Pars$step[c(3,4)]))  # sd
  angle0 <- c(Pars$angle, 3)
  max_dep0 <- c(Pars$max_dep[c(1,2)], 25, # mu
                Pars$max_dep[c(3,4)], 10) # sd
  bott_dist0 <- c(Pars$bott_dist[c(1,2)], mean(Pars$bott_dist[c(1,2)]), # mu
                  Pars$bott_dist[c(3,4)], mean(Pars$bott_dist[c(3,4)]), # sd
                  Pars$bott_dist[c(5,6)], mean(Pars$bott_dist[c(5,6)]))# zm
  Par0 <- list(step = step0, angle = angle0, max_dep = max_dep0, bott_dist = bott_dist0)

# fit 3-state HMM
set.seed(1)
HMM_move_dive_3s <- fitHMM(tracks_dives, nbStates=nbStates, stateNames=stateNames, dist=dist, Par0=Par0)
```

```{r review_3_state_HMM, attr.source = ".numberLines", cache=T}
plotPR(HMM_move_dive_3s)
plot(HMM_move_dive_3s, breaks = 100, ask = FALSE)
```

Interestingly, the `step` and `angle` QQ-plots were not improved much, though the `step` ACF was improved. However, compared to the 2-state model, there was a drastic improvement in QQ-plot and ACF the `max_dep` data stream and marginal improvement in the `bott_dist` data stream. The newly described state appears to have very low step length, really wide turning angle, minimal diving, and minimal at-depth activity, which may actually be indicative of resting. The "resident" state has intermediate speed and turning angle, but very deep dives and high at-depth activity, suggesting it may represent foraging. Let's try to fit one more 4-state HMM, to try and address the remaining residuals: intermediate speed, lower angle concentration, and more intermediate dives, which may represent searching behaviour.

```{r 4_state_HMM, cache=TRUE, attr.source = ".numberLines"}
# define states
stateNames <- c("forage", "travel", "rest", "search")
nbStates <- length(stateNames)
# Starting Pars 
  # get Pars from last HMM_move_dive HMM
  Pars <- getPar(HMM_move_dive_3s)$Par 

  # combine starting Pars 
  step0 <- c(Pars$step[c(1:3)], mean(Pars$step[3]),  # mu
             Pars$step[c(4:6)], mean(Pars$step[6]))  # sd
  angle0 <- c(Pars$angle, Pars$angle[3])
  max_dep0 <- c(Pars$max_dep[c(1:2)], Pars$max_dep[3]/2, Pars$max_dep[3], # mu
                Pars$max_dep[c(4:5)], Pars$max_dep[6]/2, Pars$max_dep[6]) # sd
  bott_dist0 <- c(Pars$bott_dist[c(1:3)], Pars$bott_dist[3], # mu
                  Pars$bott_dist[c(4:6)], Pars$bott_dist[6], # sd
                  Pars$bott_dist[c(7:9)], Pars$bott_dist[9]) # zm
  Par0 <- list(step = step0, angle = angle0, max_dep = max_dep0, bott_dist = bott_dist0)

# fit 4-state HM
set.seed(1)
HMM_move_dive_4s <- fitHMM(tracks_dives, nbStates=nbStates, stateNames=stateNames, dist=dist, Par0=Par0)

# view output
plotPR(HMM_move_dive_4s)
plot(HMM_move_dive_4s, breaks = 200)
```

The QQ-plot for `step` is quite a bit improved, as is for `bott_dist`. The ACF for `step` is also quite improved. At this point, I'm not sure the model can be significantly improved with the existing data. Although HMMs with different number of states generally shouldn't be compared, since AIC generally favours more states, it is a good sanity check. 

<!-- MAM: maybe reference Pohle for some of these statements -->
```{r HMM state AIC, attr.source = ".numberLines"}
AIC(HMM_move_dive, HMM_move_dive_3s, HMM_move_dive_4s)
```

## Covariates on emission probabilities

Thus far, we discussed various methods to regularise your data if you have missing locations and calculating and integrating dive metrics into HMMs, and in yesterday's tutorial we discussed incorporating covariates on the state transition probability. `momentuHMM` also provides the option to include covariates on the emission probability, that is, the distribution parameters (e.g., step length mean or sd) could depend on covariates. For example, we may predict that the apparent swim speed (e.g., mean step length) may depend on ocean current speed. This section will show how to integrate covariates into the emission probabilities for mean step length and mean turning angle.

### Covariates on step length emission probability
This section will illustrate how to model narwhal step length as a function of tidal currents. The narwhals in this tutorial primarily occupy the Eclipse sound system, where incoming tides lead to tidal currents into the fjords, and outgoing tides lead to tidal currents out of the fjords. Unfortunately, there is high resolution measurement data or modelled data of tidal currents in this system. However, there are general models based on lunar and solar cycles and broad-scale coast lines that we can use for the purposes of this tutorial. Specifically, we will use the `calc_earthtide` function from the `earthtide` package to estimate horizontal displacement; as the model does not take into account coastlines, the specific direction of tides cannot be used, but general patterns of still water or tide-driven currents should hold. For this section, we will use the CRW data with voided gaps. First, we must project the data into lat long (WGS84).
```{r project_tracks_crw_to_WGS84, attr.source = ".numberLines", cache=TRUE}
# re-project crw data to WGS84
prep_tracks_gps_crw_NAgaps_wgs84 <- 
  prep_tracks_gps_crw_NAgaps %>% 
  as.data.frame() %>%  # convert from momentuHMM object to data frame
  st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
  st_set_crs(2962) %>%  # specify projection of daat
  st_transform(4326) # re-project data to a lat long

# define x and y colums and remove sf geometry
prep_tracks_gps_crw_NAgaps_wgs84 <- prep_tracks_gps_crw_NAgaps_wgs84 %>% 
  mutate(x = st_coordinates(prep_tracks_gps_crw_NAgaps_wgs84)[,"X"], 
         y = st_coordinates(prep_tracks_gps_crw_NAgaps_wgs84)[,"Y"]) %>%
  st_drop_geometry()
```

At the small scale we are using, there is not much spatial variation in the tides, so for faster processing, we can just estimate tidal currents at each narwhal time step using the coordinates for the centre of Eclipse sound based.
```{r get_htide, attr.source = ".numberLines", cache=TRUE}
prep_tracks_gps_crw_NAgaps_wgs84 <- prep_tracks_gps_crw_NAgaps_wgs84 %>% 
  group_by(ID) %>%  # calc_earthtide assumes data is chronological, so we must group data by narwhal ID
  mutate(htide = calc_earthtide(utc = time,
                                do_predict = TRUE,
                                method = 'horizontal_displacement',
                                latitude = 72.6,
                                longitude = -79.7)[,2]) 
# invert the horizontal_displacement so values are strictly positive (I'm not sure what the units for this variable are)
prep_tracks_gps_crw_NAgaps$htide <- -prep_tracks_gps_crw_NAgaps_wgs84$htide + 10 

# plot tide data as afunction of time
plot(htide ~ time, prep_tracks_gps_crw_NAgaps, type = 'l')
```

If narwhal movement occurred at a larger scale (e.g., if we studied a longer period), and we wanted to estimate tidal currents independently for each location, we could use the following code (not run):

```{r get_htide_rowwise, attr.source = ".numberLines", eval=F}
prep_tracks_gps_crw_NAgaps_wgs84 <- prep_tracks_gps_crw_NAgaps_wgs84 %>%
  rowwise() %>%  # must apply calc_earthtide function independently to each row
  mutate(htide = calc_earthtide(utc = time,
                                do_predict = TRUE,
                                method = 'horizontal_displacement',
                                latitude = y,  # use x,y coordinates from each row
                                longitude = x)[,2]) %>%
  ungroup()  # ungroup data so future analysis is not conducted rowwise
```

Next, we can define the model structure including the design matrix, which can be used to specify effects of covariates.
Note: when specifying a design matrix with DM, starting parameters (i.e., Par0) must be specified on the working scale (i.e., -inf,inf), therefore, we apply a log transformation for the mean and sd for step.
```{r prep_HMM_StepTides, message=FALSE, attr.source = ".numberLines", cache=TRUE}
set.seed(1)
# define state names (optional)
stateNames <- c("resident", "travel")
# define number of states
nbState <- length(stateNames)

# define distributions for each data stream
dist <- list(step = "gamma", angle = "vm")

# define step formula and design matrix
stepDM <- list(mean = ~ htide, sd = ~ 1)
DM <- list(step = stepDM)

# define starting values
mu0 <- log(c(200, 1,  # state 1 step mean: intercept + slope (working scale)
             500, 1)) # state 2 step mean: intercept + slope (working scale)
sigma0 <- log(c(150, 300)) # SD of the step length (working scale)
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)
```

Now we can fit the HMM, plot the output, and view the estimated parameters with confidence intervals. Note, when the model has covariates, you can include `plotCI = T` to include the 95% confidence intervals on the estimated value.
```{r fit_HMM_StepTides, message=FALSE, attr.source = ".numberLines", cache=TRUE}
# Fit a 2 state HMM
HMM_StepTides <- fitHMM(prep_tracks_gps_crw_NAgaps, nbState = nbState, dist = dist, Par0 = Par0, DM = DM, stateNames = stateNames)

# plot
plot(HMM_StepTides, ask = FALSE, plotCI = T)

# show parameter estimates and confidence intervals
HMM_StepTides$CIbeta$step[c("est", "lower", "upper")] %>%  # get estimate and CI
  lapply(as.vector) %>%  # convert est, lower, and upper to vectors
  do.call(cbind, .) %>%  # cbind est, lower, and upper into a data.frame
  data.frame(names = colnames(HMM_StepTides$mle$step), .) %>%  # add column for beta names
  kable(digits = 3)  # output table with 3 decimal places on values
```
Based on the first plot and the negative and positive confidence intervals for `mean_1:htide`, it does not appear there is a relationship between tidal currents and speed for the resident state. However, there may be a positive relationship with speed for the travelling state. These results align with the prediction that narwhal movement is random relative to tides during the resident state and that movement tends to be with tidal current during the travelling state to save energy. `momentuHMM` has special functions that allow us to specify state-specific effects of covariates, namely: `state`, `toState`, and `betaCol`. Using `state2(htide)` in the DM for step length, we specify that tidal currents only affect the travelling state (state 2) as follows: 

```{r prep_fit_HMM_S2StepTides, message=FALSE, attr.source = ".numberLines", cache=TRUE}
set.seed(1)
# define starting values
mu0 <- log(c(200, 500, 1)) # Mean step length (working scale)
sigma0 <- log(c(150, 300)) # Sd of the step length (working scale)
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)
Par0 <- list(step = c(mu0, sigma0), angle = kappa0)

# define formula. 
# state 2 mean is a function of htide
stepDM <- list(mean = ~ state2(htide), sd = ~ 1)
DM <- list(step = stepDM)

# Fit HMM
HMM_S2StepTides <- fitHMM(prep_tracks_gps_crw_NAgaps, nbState = nbState, dist = dist, Par0 = Par0, DM = DM, stateNames = stateNames)

# plot
plot(HMM_S2StepTides, ask = FALSE, plotCI = T)

# show parameter estimates and confidence intervals
HMM_S2StepTides$CIbeta$step[c("est", "lower", "upper")] %>%  # get estimate and CI
  lapply(as.vector) %>%  # convert to vectors
  do.call(cbind, .) %>%  # cbind into data.frame
  data.frame(names = colnames(HMM_S2StepTides$mle$step), .) %>%  # add beta names
  kable(digits = 3)  # output table
```
Here we see that tidal effects do appear to affect step length in state 2. As the observation data is the same between this model and the model in section \@ref(void_gaps), we can use AIC to compare models with and without tidal data. 
```{r AIC_htides_HMMs, attr.source = ".numberLines"}
AIC(HMM_gps_crw_NAgaps)  # without tide data
AIC(HMM_StepTides)  # tidal effects on state 1 and state 2 step length
AIC(HMM_S2StepTides)  # tidal effects on state 2 step length
```
In this case, the original model without tidal effects had the best AIC, suggesting that including tides did not explain enough additional variation to warrant the additional parameter. 

For me, using the special functions (i.e.,, `state` and `toState`, and `betaCol`) can get confusing. Instead, I prefer to define pseudo-DMs explicitly so I know exactly how each parameter is defined. The previous HMM can be identically defined using the following code (we will not run this):
```{r DM_HMM_S2StepTides, eval=FALSE, attr.source = ".numberLines"}
# define pseudo-design matrix
                 # b1 b2 b3      b4 b5
stepDM <- matrix(c(1, 0, 0,      0, 0, # mean 1 (intercept-only)
                   0, 1, "htide",0, 0, # mean 2 (intercept + slope*htide)
                   0, 0, 0,      1, 0, # sd 1 (intercept-only)
                   0, 0, 0,      0, 1),# sd 2 (intercept-only)
                 byrow = T, nrow = nbState*2, 
                 dimnames = list(c("mean_1","mean_2","sd_1","sd_2"),
                                 c("mean_1", "mean_2:int", "mean_2:htide", "sd_1", "sd_2")))
DM <- list(step = stepDM)
```
Note: adding dimension names is optional, but can help with interpretation. Remember, each row of the DM corresponds with the state-specific distribution parameters and each column represents the beta coefficients estimated by the model. A basic HMM without any covariates is effectively using a diagonal matrix of 1s. Multiple values in one row are added multiplied by their respective beta coefficients then transformed using the link function (in this case, log for mean and SD). Mathematically, the above DM can be written as follows:
\begin{equation} \label{eq:sl}
  \begin{aligned}
      \log\mu_{S,t}^{(l)} &= 
        \begin{cases}
             \begin{aligned}
             & \beta_{1} \\
             & \beta_{2} + \beta_{3}r^{($htide$)}_t \\
             \end{aligned}
        \end{cases}
        \quad
        \begin{aligned}
        & \mathrm{if} \: S = \mathrm{resident}\\
        & \mathrm{if} \: S = \mathrm{travel}\\
        \end{aligned} \\
      \log\sigma_{S,t}^{(l)} &= 
        \begin{cases}
             \begin{aligned}
             & \beta_{3} \\
             & \beta_{4} \\
             \end{aligned}
        \end{cases}
        \quad
        \begin{aligned}
        & \mathrm{if} \: S = \mathrm{resident}\\
        & \mathrm{if} \: S = \mathrm{travel},\\
        \end{aligned}
  \end{aligned}
\end{equation}  
where $\mu_S^{(l)}$ is the state-specific mean of step length, $\sigma_{S}^{(l)}$ is the state-specific SD of step length, $\beta \in (-\infty, \infty)$ are the beta coefficients estimated by the model, and $r^{(htide)}_t$ is the rate of horizontal tide movement at time $t$.

### cov on turn angle 
```{r eval=FALSE, include=FALSE}
head(prep_tracks_gps_crw_NAgaps)
hist(prep_tracks_gps_crw_NAgaps$step)
temp <- prep_tracks_gps_crw_NAgaps
temp$state <- viterbi(HMM_gps_crw_NAgaps)
temp %>% 
  mutate(hour = hour(time)) %>% 
  filter(state == 2) %>% 
  group_by(hour) %>% 
  summarise(mu_step = mean(step, na.rm = T),
            sd_step = sd(step, na.rm = T)/sqrt(n())) %>% 
  plot()
# install.packages("earthtide")
library(earthtide)

tide_hdisp<- calc_earthtide(utc = tms,
                            do_predict = TRUE,
                            method = 'horizontal_displacement',
                            latitude = 52.3868,
                            longitude = 9.7144)




tms <- as.POSIXct("2017-08-07", tz = "UTC") + 0:(24*10) * 3600

tide_ocean <- calc_earthtide(utc = tms, 
                               method = 'ocean_tides',
                               latitude = 72.817443,
                               longitude = -78.049349)
# tide_gravity <- calc_earthtide(utc = tms,
#                                do_predict = TRUE,
#                                method = 'gravity',
#                                latitude = 52.3868,
#                                longitude = 9.7144)
# tide_tidal_potential<- calc_earthtide(utc = tms,
#                                do_predict = TRUE,
#                                method = 'tidal_potential',
#                                latitude = 52.3868,
#                                longitude = 9.7144)
tide_hdisp<- calc_earthtide(utc = tms,
                               do_predict = TRUE,
                               method = 'horizontal_displacement',
                               latitude = 52.3868,
                               longitude = 9.7144)
# tide_vdisp<- calc_earthtide(utc = tms,
#                                do_predict = TRUE,
#                                method = 'vertical_displacement',
#                                latitude = 52.3868,
#                                longitude = 9.7144)
# plot(tide_gravity, type = 'l')
# plot(tide_tidal_potential, type = 'l')
plot(tide_ocean, type = 'l', main = "tide height", ylim = c(-300,50))
points(-horizontal_displacement~datetime, data = tide_hdisp, type = 'l', main = "h hisp")
# plot(-vertical_displacement~datetime, data = tide_vdisp, type = 'l')

plot(x = tide_ocean$ocean_tides, y = tide_gravity$gravity)
```

<!-- ## play -->
<!-- ```{r} -->
<!-- library(psych) -->
<!-- library(plotly) -->
<!-- # plot states -->
<!-- model <- HMM_max_dep -->
<!-- dat <- tracks_dives %>% -->
<!--   mutate(max_dep = (max_dep), -->
<!--          bott_dist = (bott_dist), -->
<!--          state = viterbi(model)) %>% -->
<!--   dplyr::select(max_dep, bott_dist, step, angle, state) -->

<!-- plot_ly(dat, x = ~log(step), y = ~sqrt(abs(angle)), z = ~-max_dep,color = ~factor(state),  size = 1) -->
<!-- ``` -->

<!-- One additional option to select which dive data stream to use, is to  and examine which performs better. All of dive data streams are zero-bound, therefore, we can the gamma, log normal, or Weibull distrutions to describe them. For simplicity, we will use the gamma for all, and also divide each data stream by its respective standard deviation to standardise them. -->

<!-- ```{r prep dive data and independent HMMs, message=FALSE} -->
<!-- # standardise dive variables (not necessary) -->
<!-- tracks_dives_prep <- tracks_dives %>% -->
<!--   mutate(max_dep = max_dep/sd(max_dep, na.rm = T), -->
<!--          dive_t = dive_t/sd(dive_t, na.rm = T), -->
<!--          mean_dep = mean_dep/sd(mean_dep, na.rm = T), -->
<!--          max_dive_dep = max_dive_dep/sd(max_dive_dep, na.rm = T), -->
<!--          bott_dist = bott_dist/sd(bott_dist, na.rm = T)) -->

<!-- # identify whether there is 0 data -->
<!-- tracks_dives %>% -->
<!--   summarise(max_dep = sum(max_dep==0, na.rm = T), -->
<!--             dive_t = sum(dive_t==0, na.rm = T), -->
<!--             mean_dep = sum(mean_dep==0, na.rm = T), -->
<!--             max_dive_dep = sum(max_dive_dep==0, na.rm = T), -->
<!--             bott_dist = sum(bott_dist==0, na.rm = T)) -->
<!-- # therefore, we need to include zero-mass parameters for dive_t and bott_dist -->

<!-- # fit dive-only HMMs -->
<!-- set.seed(1) -->
<!-- HMM_max_dep <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(max_dep="gamma"), -->
<!--                       Par0 = list(max_dep = c(mu0, sigma0))) -->
<!-- HMM_dive_t <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(dive_t="gamma"), -->
<!--                      Par0 = list(dive_t = c(mu0, sigma0, zm))) -->
<!-- HMM_mean_dep <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(mean_dep="gamma"), -->
<!--                        Par0 = list(mean_dep = c(mu0, sigma0))) -->
<!-- HMM_max_dive_dep <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(max_dive_dep="gamma"), -->
<!--                            Par0 = list(max_dive_dep = c(mu0, sigma0))) -->
<!-- HMM_bott_dist <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(bott_dist="gamma"), -->
<!--                         Par0 = list(bott_dist = c(mu0, sigma0, zm))) -->
<!-- ``` -->
<!-- Now, to compare the models, we cannot use standard metrics of AIC, likelihood, or r$^2$ since the response data (the dive variables) are all different. However, we can look at metrics of -->
<!-- ---- to be continued ----- -->
<!-- ```{r compare dive-only HMMs, message=FALSE, eval = F} -->
<!-- plotPR(HMM_max_dep) -->
<!-- plotPR(HMM_dive_t) -->
<!-- plotPR(HMM_mean_dep) -->
<!-- plotPR(HMM_max_dive_dep) -->
<!-- plotPR(HMM_bott_dist) -->

<!-- plot(HMM_max_dep, ask = F) -->
<!-- plot(HMM_dive_t, ask = F) -->
<!-- plot(HMM_mean_dep, ask = T) -->
<!-- plot(HMM_max_dive_dep, ask = T) -->
<!-- plot(HMM_bott_dist, ask = F) -->
<!-- plot(HMM_gps_crw_NAgaps, ask = F) -->

<!-- filter(tracks_dives_prep, ID == "T172062") %>% -->
<!--   ggplot(aes(x = x, y = y, col = mean_dep)) + -->
<!--   geom_point() + theme_classic()  # 1 -->
<!-- filter(tracks_dives_prep, ID == "T172062") %>% -->
<!--   ggplot(aes(x = x, y = y, col = max_dep)) + -->
<!--   geom_point() + theme_classic()  # 1 -->
<!-- filter(tracks_dives_prep, ID == "T172062") %>% -->
<!--   ggplot(aes(x = x, y = y, col = dive_t)) + -->
<!--   geom_point() + theme_classic() #  1 -->
<!-- filter(tracks_dives_prep, ID == "T172062") %>% -->
<!--   ggplot(aes(x = x, y = y, col = max_dive_dep)) + -->
<!--   geom_point() + theme_classic() # -->
<!-- filter(tracks_dives_prep, ID == "T172062") %>% -->
<!--   ggplot(aes(x = x, y = y, col = bott_dist)) + -->
<!--   geom_point() + theme_classic() # -->


<!-- AIC(HMM_max_dep, HMM_dive_t, HMM_mean_dep, HMM_max_dive_dep, HMM_bott_dist) -->

<!-- f <- which(!is.na(prep_tracks_gps_crw_NAgaps$step)) -->
<!-- states_sa <- viterbi(HMM_gps_crw_NAgaps)[f] -->

<!-- data.frame(max_dep = sum(viterbi(HMM_max_dep)[f]==states_sa), -->
<!--            dive_t = sum(viterbi(HMM_dive_t)[f]==states_sa), -->
<!--            mean_dep = sum(viterbi(HMM_mean_dep)[f]==states_sa), -->
<!--            max_dive_dep = sum(viterbi(HMM_max_dive_dep)[f]==states_sa), -->
<!--            bott_dist = sum(viterbi(HMM_bott_dist)[f]==states_sa)) -->



<!-- pairs.panels(tracks_dives_prep[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", -->
<!--              "bott_dist", "step", "angle")], -->
<!--              gap = 0, -->
<!--              pch=21) -->

<!-- pairs.panels(cbind(tracks_dives_prep[,c("max_dep", "bott_dist", "step")], -->
<!--                    abs(tracks_dives_prep[,c("angle")])), -->
<!--              gap = 0, -->
<!--              pch=20) -->
<!-- # plot states -->
<!-- dat <- tracks_dives_prep %>% -->
<!--   mutate(max_dep = log(max_dep), -->
<!--          bott_dist = log(bott_dist), -->
<!--          state = viterbi(HMM_move_dive_3s)) %>% -->
<!--   dplyr::select(max_dep, bott_dist, step, angle, state) -->
<!-- ggplot(dat, aes(x = step, y = angle, col = state)) + -->
<!--   geom_point(shape = 20) -->
<!-- ggplot(dat, aes(x = step, y = max_dep, col = state)) + -->
<!--   geom_point(shape = 20) -->

<!-- plot_ly(dat, x = ~log(step), y = ~abs(angle), z = ~-max_dep, color = ~factor(state), size = 1) -->
<!-- plot_ly(dat, x = ~log(step), y = ~sqrt(abs(angle)), z = ~-max_dep,  size = 1) -->
<!-- plot_ly(dat, x = ~log(step), y = ~sqrt(abs(angle)), z = ~-max_dep,color = ~factor(state),  size = 1) -->
<!-- plot_ly(dat, x = ~log(step), y = ~bott_dist, z = ~-max_dep,color = ~factor(state),  size = 1) -->

<!-- plot_ly(dat, x = ~step, y = ~max_dep, z = ~bott_dist, size = 1) -->
<!-- plot_ly(dat, x = ~abs(angle), y = ~max_dep, z = ~bott_dist, size = 1) -->

<!-- # PCA -->
<!-- dat <- tracks_dives_prep %>% -->
<!--   mutate(max_dep = log(max_dep), -->
<!--          bott_dist = log(bott_dist), -->
<!--          state = viterbi(HMM_move_dive_3s)) %>% -->
<!--   dplyr::select(max_dep, bott_dist, step, angle) %>% -->
<!--   na.omit() %>% -->
<!--   {.[!is.infinite(rowSums(.)),]} -->

<!-- pairs.panels(dat, -->

<!--              gap = 0, -->
<!--              pch=20) -->
<!-- pc <- prcomp(na.omit(dat[!is.infinite(rowSums(dat[,c("max_dep", "bott_dist", "step", "angle")])), -->
<!--                          c("max_dep", "bott_dist", "step", "angle")]), -->
<!--              center = TRUE, -->
<!--             scale. = TRUE) -->
<!-- print(pc) -->
<!-- ggplot(dat, aes(x = step, y = angle, col = state)) + -->
<!--   geom_point() -->
<!-- # PCA -->
<!-- dat <- tracks_dives_prep %>% -->
<!--   mutate(mean_dep = log(mean_dep), -->
<!--          max_dep = log(max_dep), -->
<!--          dive_t = log(dive_t), -->
<!--          bott_t = log(bott_t), -->
<!--          prop_bott = logit(prop_bott), -->
<!--          max_dive_dep = log(max_dive_dep), -->
<!--          bott_dist = log(bott_dist), -->
<!--          post_dive_dur = log(post_dive_dur), -->
<!--          state = viterbi(HMM_gps_crw_NAgaps)) %>% -->
<!--   dplyr::select(max_dep, dive_t, mean_dep, max_dive_dep, bott_dist, step, angle) %>% -->
<!--   na.omit() %>% -->
<!--   {.[!is.infinite(rowSums(.)),]} -->

<!-- pairs.panels(dat, -->
<!--              gap = 0, -->
<!--              pch=21) -->
<!-- dat %>% -->
<!-- cor() %>% -->
<!--   corrplot(method="number") -->

<!-- tracks_dives[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", -->
<!--              "bott_dist", "step", "angle")] %>% -->
<!--   na.omit() %>% {.[!is.infinite(rowSums(.)),]} %>% nrow() -->

<!-- pc <- prcomp(na.omit(dat[!is.infinite(rowSums(dat[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", "bott_dist", "step", "angle")])), -->
<!--                          c("max_dep", "dive_t", "mean_dep", "max_dive_dep", "bott_dist", "step", "angle")]), -->
<!--              center = TRUE, -->
<!--             scale. = TRUE) -->
<!-- attributes(pc) -->
<!-- print(pc) -->
<!-- library(factoextra) -->
<!-- fviz_eig(pc) -->
<!-- groups <- as.factor(na.omit(dat[!is.infinite(rowSums(dat[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", "bott_dist", "step", "angle")])),])[,"state"]) -->
<!-- fviz_pca_ind(pc, -->
<!--              col.ind = groups, # color by groups -->
<!--              palette = c("#00AFBB",  "#FC4E07"), -->
<!--              addEllipses = TRUE, # Concentration ellipses -->
<!--              ellipse.type = "confidence", -->
<!--              legend.title = "Groups", -->
<!--              repel = TRUE -->
<!--              ) -->

<!-- library(ggfortify) -->
<!-- df <- iris[1:4] -->
<!-- pca_res <- prcomp(df, scale. = TRUE) -->

<!-- autoplot(pca_res) -->
<!-- ``` -->








<!-- ```{r calibrate_TDR_extra, warning=FALSE} -->
<!-- i = 0 -->
<!-- plot(dives$depth*-1, pch = 19, type = 'l', xlim = c(1,8)+8*i, ylim = c(-100,0)); i = i+1 -->
<!-- i = 0 -->
<!-- plot(dives$dt, pch = 19, xlim = c(1,100)+100*i); i = i+1 -->
<!-- # regularise dive -->
<!-- hist(dives$depth,2000, xlim = c(0,200)) -->




<!-- # round time to nearest 10 min -->
<!-- # summarise -->
<!-- ## max depth -->
<!-- ## mean depth -->
<!-- ## 3rd quantile of depth -->
<!-- ## number of dives -->
<!-- ## number small vs short dives -->
<!-- ## time at depth -->
<!-- ## percent to bottom -->
<!-- ## depth variance -->
<!-- ## dive type (which dive is most ) -->
<!-- # method of summary strongly depends on resolution of HMM. in some cases, individual dives can last longer than the HMM step, and depending on when within the 10 min step a dive starts, we may capture the entirety or just a portion of the dive (e.g., ascent, and descent). Conversely, with lower time locations, we may have a number of dives in each step that must be summarised (e.g., number of dives) -->

<!-- library(terra) -->
<!-- bath <- rast("data/gebco_2022_n74.0_s71.5_w-82.0_e-77.0.tif") %>% -->
<!--   crop(ext(-82, -76, 72, 73)) -->





<!-- ``` -->

<!-- ```{r plot all tracks} -->
<!-- # convert to lines and plot using tmap -->
<!-- tracks_proj %>% group_by(ID) %>% -->
<!--   summarise(do_union = F) %>% -->
<!--   st_cast("LINESTRING") %>% -->
<!--      tm_shape() + -->
<!--    tm_lines(col = "ID", palette = "Dark2") -->

<!-- ``` -->

<!-- ```{r} -->
<!-- # first passage time -->
<!-- tracks_high <- filter(tracks_proj, loc_class %in% c("GPS", 3, 2, 1)) -->
<!-- ltraj <- as.ltraj(xy = cbind(st_coordinates(tracks_high)[,"X"], -->
<!--                              st_coordinates(tracks_high)[,"Y"]), -->
<!--                   date = tracks_high$time, id=factor(tracks_high$ID)) -->
<!-- fpt_low <- fpt(ltraj, seq(100, 3000, length=100), units = "hours") %>% -->
<!--   varlogfpt() -->
<!-- fpt_med <- fpt(ltraj, seq(3000, 20000, length=200), units = "hours") %>% -->
<!--   varlogfpt() -->
<!-- fpt_hig <- fpt(ltraj, seq(20000, 100000, length=200), units = "hours") %>% -->
<!--   varlogfpt() -->
<!-- fpt(ltraj, 1500, units = "hours") %>% unlist %>% mean(na.rm = T)/40 -->
<!-- fpt(ltraj, 15000, units = "hours") %>% unlist %>% mean(na.rm = T)/40 -->
<!-- fpt(ltraj, 40000, units = "hours") %>% unlist %>% mean(na.rm = T)/40 -->
<!-- # looks like there are are increases/plateaus of variance at around 1.5, 15, 40, & 80 km -->
<!-- ``` -->


Argos data section - for now removed. We could do an extra tutorial.

<!-- ## Dealing with location error and irregular time -->
<!-- Thus far, we have been using exclusively the GPS data, which can be assumed to have a negligible error in most applications. However, in many marine systems, we may obtain ARGOS locations, which can have highly variable location error on the order of hundreds of meters to hundreds of km. In addition, ARGOS data often provides location estimates in very irregular time intervals. `crawlWrap` can be used not only to predict impute missing data, but also to predict location when faced with high location error and irregular time-series. -->

<!-- ```{r filter_argos} -->
<!-- # filter argos data -->
<!-- tracks_argos <- filter(tracks_proj, loc_class != "GPS") %>% -->
<!--   # calculate dime difference -->
<!--   mutate(dt = ifelse(ID == lead(ID), -->
<!--                      difftime(lead(time), time, units = "mins"), NA), -->
<!--          # define location class factor levels   -->
<!--          loc_class = factor(loc_class,       -->
<!--                             levels = c(3, 2, 1, 0, "A", "B"))) -->
<!-- ``` -->
<!-- Note: It is possible to include both GPS and ARGOS data in one model (you would define the levels as such: `levels = c("GPS", 3, 2, 1, 0, "A", "B")'. However, for this example, we will illustrate the more difficult scenario using only ARGOS data and use the GPS data as a measure of model performance. -->
<!-- Visualize ARGOS tracks. -->

<!-- ```{r plot_original_data, message=FALSE} -->
<!-- # convert to lines and plot using tmap -->
<!-- tracks_argos %>% -->
<!--   group_by(ID) %>% -->
<!--   summarise(do_union = FALSE) %>% -->
<!--   st_cast("LINESTRING") %>% -->
<!--   tm_shape() + -->
<!--   tm_sf(col = "ID", palette = "Dark2") -->
<!-- ``` -->

<!-- Notice how much more noise there is in this data compared to the gps tracks. In addition, it looks like there are at least several outlier points. We can address most of these using a coarse speed filter. However, before we can calculate speed ($\frac{\Delta dist}{\Delta t}$), we must address the duplicate time-stamps (since we cannot divide by 0 to calculate speed). It is often not possible to reliably identify which record is more accurate to discard. Therefore, it's best to retain as as much data and offset duplicate times slightly. We will first offset duplicate times by adding 10s for each consecutive row with a `dt == 0`. -->

<!-- <!-- MAM: why 10 sec? Is there are reason not to go to one sec? --> -->

<!-- ```{r offset_duplicate_times, message=FALSE} -->
<!-- # 1) count the run length of each time step using rle -->
<!-- run_length <- rle(tracks_argos$dt)$lengths -->
<!-- # 2) create a sequence of 1:run_length for each time step -->
<!-- run_seqence <- sequence(run_length) -->
<!-- # 3) discount each time step that's not a duplicate by multiplying by 0 -->
<!-- run_seqence <- run_seqence*(tracks_argos$dt==0) -->
<!-- # 4) lag run_sequence by one row and replace the first value by 0, -->
<!-- # so that we iterate each time that is a duplicate of the previous row -->
<!-- tracks_argos$duplicate_count <- replace_na(lag(run_seqence), 0) -->
<!-- # offset duplicate times by 10s -->
<!-- tracks_argos <- -->
<!--   tracks_argos %>% -->
<!--   mutate(time = time + 10*duplicate_count, -->
<!--          # recalculate time difference -->
<!--          dt = ifelse(ID == lead(ID), -->
<!--     difftime(lead(time), time, units = "mins"), NA -->
<!--   )) -->

<!-- # last we ensure there are no identical times -->
<!-- sum(tracks_argos$time == lead(tracks_argos$time), na.rm = TRUE) -->
<!-- ``` -->

<!-- <!-- MAM: why are you using a speed filter? Aren't you using crawl to handle the error? You might want to explain why. --> -->

<!-- Now, we can apply a speed filter to remove locations that are faster than some threshold -- in this case we will exclude any locations $>10$ m/s from the previous location. -->

<!-- ```{r speed_filter, message=FALSE} -->
<!-- # distance from previous location -->
<!-- delta_dist <- st_distance(tracks_argos, lag(tracks_argos), by_element=TRUE) -->
<!-- # time from previous location -->
<!-- delta_t <- set_units(lag(tracks_argos$dt), "min") -->
<!-- # calculate speed -->
<!-- tracks_argos$spd <- delta_dist/delta_t -->

<!-- # filter speed -->
<!-- tracks_argos <- tracks_argos %>% -->
<!--   filter(spd < set_units(10, "m/s")) -->

<!-- # convert to lines and plot -->
<!-- tracks_argos %>% group_by(ID) %>% -->
<!--   summarise(do_union = F) %>% -->
<!--   st_cast("LINESTRING") %>% -->
<!--      tm_shape()+ -->
<!--    tm_lines(col = "ID", palette = "Dark2") -->
<!-- ``` -->

<!-- Already looking much better. -->

<!-- location accuracy (ignoring duplicate locations) -->
<!-- ```{r loc_class_freq} -->
<!-- # identify proportion of each location class -->
<!-- tracks_argos %>% -->
<!--   filter(dt > 0) %>% -->
<!--   {table(.$loc_class)/nrow(tracks_argos)} -->
<!-- ``` -->

<!-- we have to deal with location error, irregular time, and missing locations. The `crawl` model that we fit earlier can be extended to predict tracks from irregular data with location error. In this section, we will cover using `crawlWrap` to amputate regular locations when faced with more difficult data (e.g., ARGOS) and fitting an HMM to multiple imputed data. -->

<!-- <!-- MAM: here you have to put a bit more info on crawl. I.e. it's a state space models that handle error, etc. --> -->

<!-- First let's identify a resolution to work at if only obtained ARGOS data. -->

<!-- ```{r select_ARGOS_resolution} -->
<!-- # visualise time differences -->
<!-- hist(tracks_argos$dt[tracks_argos$dt<180], 32, -->
<!--      main = NA, xlab = "Time difference (min)") -->

<!-- # summarise track dt -->
<!-- tracks_argos %>%  -->
<!--   st_drop_geometry() %>%  -->
<!--   group_by(ID) %>%  -->
<!--   summarise(p_NA_10m = p_na(time, n_loc, 10),  # 10 min  -->
<!--             p_NA_20m = p_na(time, n_loc, 20),  # 20 min  -->
<!--             p_NA_30m = p_na(time, n_loc, 30),  # 30 min  -->
<!--             p_NA_45m = p_na(time, n_loc, 45),  # 45 min  -->
<!--             p_NA_60m = p_na(time, n_loc, 60))  # 60 min  -->
<!--             # p_NA_60m = p_na(time, n_loc, 90),  # 90 min  -->
<!--             # p_NA_60m = p_na(time, n_loc, 120)) # 120 min  -->
<!-- ``` -->

<!-- In this section, we will use 45 min as a trade-off between higher resolution and minimising data gaps. -->

<!-- Next, we will define the model structure for `crawl`. The `crawl` tutorial suggests that users define prior distributions to optimize the fit and increase the model’s ability to converge with limited/challenging data while providing the model flexibility. Here, we provide a normal distribution of the log-transformed error for each of the ARGOS error classes. The tutorial also suggest users rely on the prior distribution for the beta parameter centered on -4 (smoother fit) and, if needed, fix the beta parameter to -4 (see `crawl` tutorial [HERE](https://jmlondon.github.io/crawl-workshop/crawl-practical.html#predicting-a-movement-track)). -->

<!-- ```{r fit_45_min_crawl_to_argos_tracks, message=FALSE} -->
<!-- # split ARGOS tracks by ID -->
<!-- tracks_argos_ls <- tracks_argos %>% -->
<!--   mutate(x = st_coordinates(tracks_argos)[,"X"], -->
<!--          y = st_coordinates(tracks_argos)[,"Y"]) %>% -->
<!--   st_drop_geometry() %>% -->
<!--     split(.,.$ID) -->

<!-- # define priors -->
<!-- prior <- function(p) { -->
<!--   dnorm(p[1], log(250),  0.2, log = TRUE) +  # 3 -->
<!--   dnorm(p[2], log(500),  0.2, log = TRUE) +  # 2 -->
<!--   dnorm(p[3], log(1500), 0.2, log = TRUE) +  # 1 -->
<!--   dnorm(p[4], log(2500), 0.4, log = TRUE) +  # 0 -->
<!--   dnorm(p[5], log(2500), 0.4, log = TRUE) +  # A -->
<!--   dnorm(p[6], log(2500), 0.4, log = TRUE) +  # B -->
<!--   # skip p[7] as we won't provide a prior for sigma -->
<!--   dnorm(p[8], -4, 3, log = TRUE)  # beta parameter -->
<!-- } -->

<!-- # define error model -->
<!-- err.model <- list(x = ~ loc_class - 1, y = ~ loc_class - 1) -->

<!-- # define times to predict for easier comparison between ARGOS and GPS tracks -->
<!-- predTime <- lapply(tracks_argos_ls, function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->

<!-- # fit crawl model and predict locations at 45 min time steps -->
<!-- set.seed(1) -->
<!-- crwOut_argos_45 <- crawlWrap(tracks_argos, -->
<!--   timeStep = "45 min", -->
<!--   retryFits = 1, Time.name = "time", -->
<!--   err.model = err.model, -->
<!--   prior = prior, -->
<!--   predTime = predTime) -->
<!-- # check that each track converged (0 = converged) -->
<!-- sapply(crwOut_argos_45$crwFits, function(x)x$convergence) -->
<!-- plot(crwOut_argos_45, ask = FALSE) -->
<!-- # convert to data.frame and extract predicted locations -->
<!-- crw_argos_45 <- data.frame(crwOut_argos_45$crwPredict) %>% -->
<!--   filter(locType == "p") %>% -->
<!--   dplyr::select(mu.x, mu.y, time, ID, loc_class) %>% -->
<!--   dplyr::rename(x = "mu.x", y = "mu.y") -->
<!-- ``` -->
<!-- <!-- MAM: I get some warnings here, that something is going on --> -->

<!-- For comparison, we will also use `crawlWrap` to interpolate GPS data at a 45 min frequency/ -->

<!-- ```{r fit_45_min_crawl_to_gps_tracks, message=FALSE} -->
<!-- # fit crawl model and predict locations at 45 min time steps for GPS data -->
<!-- set.seed(1) -->
<!-- crwOut_gps_45 <- crawlWrap(obsData = tracks_gps, timeStep = "45 mins", -->
<!--                         predTime = predTime)  -->

<!-- # check that each track converged (0 = converged) -->
<!-- sapply(crwOut_gps_45$crwFits, function(x)x$convergence) -->
<!-- # convert to data.frame and extract predicted locations -->
<!-- crw_gps_45 <- data.frame(crwOut_gps_45$crwPredict) %>% -->
<!--   filter(locType == "p") %>% -->
<!--   dplyr::select(mu.x, mu.y, time, ID) %>% -->
<!--   dplyr::rename(x = "mu.x", y = "mu.y") -->

<!-- # compare estimated tracks -->
<!-- filter(crw_argos_45, ID=="T172062")  %>% -->
<!-- plot(y~x, data=., type = 'l', col = 'red', asp = 1) -->
<!-- filter(crw_gps_45, ID=="T172062") %>% -->
<!-- points(y~x, data=., type = 'l') -->

<!-- ``` -->

<!-- <!-- MAM: I get some warnings here, that something is going on --> -->

<!-- We see that there is some over lap between the ARGOS (red) and GPS (black) tracks at a 45 min resolution. However, there are some sections where the ARGOS track cuts straight lines through sections where there is variability in the GPS track. -->

<!-- Let's try to fit an HMM to the interpolated ARGOS tracks. -->
<!-- ```{r prep_ARGOS_tracks_and_fit_basic_HMM, message = FALSE} -->
<!-- # prep tracks -->
<!-- prep_argos_45 <- prepData(crw_argos_45, type = "UTM") -->
<!-- prep_gps_45 <- prepData(crw_gps_45, type = "UTM") -->

<!-- # setup model -->
<!-- dist <- list(step = "gamma", angle = "vm") -->
<!-- # Setting up the starting values -->
<!-- mu0 <- c(1000, 3000) # mu step -->
<!-- sigma0 <- mu0      # Sd step -->
<!-- kappa0 <- c(1, 3)    # kappa angle -->
<!-- Par0 <- list(step = c(mu0, sigma0), angle = kappa0) -->

<!-- # Fit a 2 state HMM for 45 min ARGOS and GPS tracks -->
<!-- set.seed(1) -->
<!-- HMM_argos_45_basic <- fitHMM(prep_argos_45, nbState = 2, dist = dist, Par0 = Par0) -->
<!-- HMM_gps_45_basic <- fitHMM(prep_gps_45, nbState = 2, dist = dist, Par0 = Par0) -->

<!-- plot(HMM_argos_45_basic, animals = "T172062", ask = F) -->
<!-- plot(HMM_gps_45_basic, animals = "T172062", ask = F) -->

<!-- # compare predicted states -->
<!-- sum(viterbi(HMM_argos_45_basic) == viterbi(HMM_gps_45_basic))/nrow(prep_argos_45) -->
<!-- ``` -->

<!-- The interpolated GPS track seems to fit, however the model had some issues fitting the ARGOS data. The ARGOS model is clearly defining all the interpolated segments as state 1 and the observed locations as state 2. Further, $<50/%$ of the predicted states from the ARGOS model are the same as the GPS model. I suspect the issue may be due to the large gaps where the interpolated track is basically linear. Indeed, in the GPS HMM, state 1 seems to primarily be classifying the straight interpolated sections as state 1 and the rest as state 2. We can try to address this by voiding large gaps using the `prepData_NAGaps` function we defined earlier. In this case, we will voiding gaps $>180$ min -->

<!-- ```{r prep_data_and_void_gaps} -->
<!-- # prep 45 min ARGOS data and void large gaps -->
<!-- prep_argos_45 <- prepData_NAGaps(track_list = tracks_argos_ls, tracks_crw = crw_argos_45, res = 45, max_gap = 180, type = "UTM") -->

<!-- # prep 45 min gps data and void large gaps -->
<!-- prep_gps_45 <- prepData_NAGaps(track_list = tracks_gps_ls, tracks_crw = crw_gps_45, res = 45, max_gap = 180, type = "UTM") -->
<!-- ``` -->

<!-- Now, let's try to fit the same HMM as above to this data with large gaps voided. -->

<!-- ```{r voided_crawl_HMM_fitHMM_argos, message=FALSE} -->
<!-- set.seed(1) -->
<!-- # Fit a 2 state HMM for 45 min ARGOS and GPS tracks -->
<!-- HMM_argos_45 <- fitHMM(prep_argos_45, nbState = 2, dist = dist, Par0 = Par0) -->
<!-- HMM_gps_45 <- fitHMM(prep_gps_45, nbState = 2, dist = dist, Par0 = Par0) -->

<!-- plot(HMM_argos_45, animals = "T172062", ask = "F") -->
<!-- plot(HMM_gps_45, animals = "T172062", ask = "F") -->
<!-- # compare new and original GPS model predicted states -->
<!-- sum(viterbi(HMM_gps_45_basic) == viterbi(HMM_gps_45))/nrow(prep_argos_45) -->
<!-- # compare new and original GPS model predicted states -->
<!-- sum(viterbi(HMM_argos_45) == viterbi(HMM_gps_45))/nrow(prep_argos_45) -->
<!-- ``` -->

<!-- Both data sets seem to fit easily. There isn't a large change between this GPS model and the previous one (without voiding large gaps); $94/%$ of the predicted states are the same. However, the overlap between the ARGOS and GPS models is much higher than previously ($74\%$), suggesting the ARGOS model with voided gaps is significantly improved. However, there is still a notable discrepancy between the ARGOS and the GPS HMMs. -->

<!-- ### Multiple imputation -->

<!-- ```{r fit_multiple_imputations} -->
<!-- mu0 <- c(1000, 3000) # mu step -->
<!-- sigma0 <- mu0      # Sd step -->
<!-- kappa0 <- c(1, 3)    # kappa angle -->
<!-- Par0 <- list(step = c(mu0, sigma0), angle = kappa0) -->

<!-- # # define priors -->
<!-- # prior <- function(p) { -->
<!-- #   dnorm(p[1], log(0.250),  0.2, log = TRUE) +  # 3 -->
<!-- #   dnorm(p[2], log(0.500),  0.2, log = TRUE) +  # 2 -->
<!-- #   dnorm(p[3], log(1.500), 0.2, log = TRUE) +  # 1 -->
<!-- #   dnorm(p[4], log(2.500), 0.4, log = TRUE) +  # 0 -->
<!-- #   dnorm(p[5], log(2.500), 0.4, log = TRUE) +  # A -->
<!-- #   dnorm(p[6], log(2.500), 0.4, log = TRUE) +  # B -->
<!-- #   # skip p[7] as we won't provide a prior for sigma -->
<!-- #   dnorm(p[8], 0, 2, log = TRUE)  # beta parameter -->
<!-- # } -->
<!-- #  -->
<!-- # # fit crawl model and predict locations at 45 min time steps -->
<!-- # set.seed(1) -->
<!-- # argos_45_crwOut <- crawlWrap(tracks_argos, -->
<!-- #   timeStep = "45 min", -->
<!-- #   retryFits = 1, Time.name = "time", -->
<!-- #   err.model = err.model, -->
<!-- #   prior = prior, -->
<!-- #   predTime = predTime) -->
<!-- #  -->
<!-- #  -->
<!-- # nfsFits <- MIfitHMM(crwOut_gps_45, nSims = 1, fit = F) -->
<!-- # nfsFits <- MIfitHMM(argos_45_crwOut, nSims = 1, nbStates = 2, dist = dist, Par0 = Par0) -->
<!-- # plot(nfsFits) -->
<!-- # set.seed(1) -->

<!-- # fit crawl to 1 gpstrack and predict locations at 45 min time stepstracks <-  -->
<!-- cwr_gps_sub <- tracks_gps %>%  -->
<!--   # filter(ID != "T172066") -->
<!--   filter(ID == "T172062") -->

<!-- predTime <- lapply(split(cwr_gps_sub,cwr_gps_sub$ID), function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->

<!-- set.seed(1) -->
<!-- crwOut_gps_T172062 <-  -->
<!--   crawlWrap(cwr_gps_sub, -->
<!--   retryFits = 1, Time.name = "time", -->
<!--   predTime = predTime) -->
<!-- crwOut_gps_T172062$crwFits$T172062 -->
<!-- # crwOut_gps_T172062$crwFits$T172064 -->

<!-- nfsFits_gps <- MIfitHMM(crwOut_gps_T172062, nSims = 10,  -->
<!--                      nbStates = 2, dist = dist, Par0 = Par0, fit = T) -->
<!-- plot(nfsFits_gps) -->

<!-- # # sub argos track ########### -->
<!-- # sub_argos <- tracks_argos %>%  -->
<!-- #     filter(ID == "T172062") %>%  -->
<!-- #     # filter(loc_class %in% c("3","2", "1", "A","B")) %>%  -->
<!-- #     list() -->
<!-- #  -->
<!-- # predTime <- lapply(sub_argos, function(x) -->
<!-- #   seq(first(x$time), last(x$time), "45 min")) -->
<!-- #  -->
<!-- # # define priors -->
<!-- # prior <-  function(p) {  -->
<!-- #       dnorm(p[1], log(50),  1, log = TRUE) +  # 3 -->
<!-- #       dnorm(p[2], log(100), 2, log = TRUE) +  # 2 -->
<!-- #       dnorm(p[3], log(500), 3, log = TRUE) +  # 1 -->
<!-- #       dnorm(p[4], log(2000), 4, log = TRUE) +  # 0 -->
<!-- #       dnorm(p[5], log(2000), 4, log = TRUE) +  # A -->
<!-- #       dnorm(p[6], log(2000), 4, log = TRUE) +  # B -->
<!-- #       # skip p[7] as we won't provide a prior for sigma -->
<!-- #       dnorm(p[8], 4, 0.2, log = TRUE)  # beta -->
<!-- # } -->
<!-- #  -->
<!-- # argos_45_crwOut_1trk <-   -->
<!-- #   crawlWrap(sub_argos[[1]],  -->
<!-- #             retryFits = 50, Time.name = "time", -->
<!-- #             err.model = err.model, -->
<!-- #             prior = prior, -->
<!-- #             predTime = predTime[[1]]) -->
<!-- #   # [which(track_T172062$loc_class %in% c("3","2", "0", "A"))]) -->
<!-- # argos_45_crwOut_1trk$crwFits$T172062 -->
<!-- # argos_45_crwOut_1trk <-   -->
<!-- #   crawlWrap(sub_argos[[1]],  -->
<!-- #             retryFits = 50, Time.name = "time", -->
<!-- #             err.model = err.model, -->
<!-- #             prior = prior, -->
<!-- #             theta  = c(), -->
<!-- #             predTime = predTime[[1]]) -->
<!-- #   # [which(track_T172062$loc_class %in% c("3","2", "0", "A"))]) -->
<!-- # argos_45_crwOut_1trk$crwFits$T172062 -->
<!-- #### sub argos track with fix par ########### -->
<!-- sub_argos <- tracks_argos %>% -->
<!--     filter(ID == "T172062") %>% -->
<!--     # filter(loc_class %in% c("3","2", "1", "A","B")) %>% -->
<!--     list() -->

<!-- predTime <- lapply(sub_argos, function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->

<!-- # define priors -->
<!-- prior <-  function(p) {  -->
<!--       # dnorm(p[1], log(50),  1, log = TRUE) +  # 3 -->
<!--       # dnorm(p[2], log(100), 2, log = TRUE) +  # 2 -->
<!--       # # dnorm(p[3], log(500), 3, log = TRUE) +  # 1 -->
<!--       # dnorm(p[1], log(2000), 1, log = TRUE) +  # 0 -->
<!--       # dnorm(p[1], log(2000), 1, log = TRUE) +  # A -->
<!--       # dnorm(p[2], log(2000), 1, log = TRUE) +  # B -->
<!--       # skip p[7] as we won't provide a prior for sigma -->
<!--       dnorm(p[2], -2, 0.1, log = TRUE)  # beta -->
<!-- } -->

<!-- fixPar <- c(log(250), log(500), log(1000),   #x -->
<!--             log(2000),log(2500),log(2500), -->
<!--             log(250), log(500), log(1000),   #y -->
<!--             log(2000),log(2500),log(2500), -->
<!--             NA, NA) # sgima, beta -->
<!-- # fixPar <- c(NA, NA, log(500),   #x -->
<!-- #             log(2500), log(2500), log(2500),   -->
<!-- #             NA, NA, log(500),  #y -->
<!-- #             log(2500), log(2500), log(2500),  -->
<!-- #             NA, NA) # sgima, beta -->

<!-- # fit -->
<!-- argos_45_crwOut_1trk <-   -->
<!--   crawlWrap(sub_argos[[1]],  -->
<!--             retryFits = 10000, retrySD = 5, -->
<!--             Time.name = "time", -->
<!--             err.model = err.model, -->
<!--             #prior = prior,  -->
<!--             fixPar = fixPar, -->
<!--             predTime = predTime[[1]]) -->
<!-- # view -->
<!-- argos_45_crwOut_1trk$crwFits$T172062 -->
<!-- # plot(argos_45_crwOut_1trk) -->

<!-- # nfsFits <- MIfitHMM(argos_45_crwOut_1trk, nSims = 1, fit = F) -->
<!-- MIfit_argos <- MIfitHMM(argos_45_crwOut_1trk, nSims = 10000, fit = T, -->
<!--                         nbStates = 2, dist = dist, ncores = ncores, -->
<!--                         Par0 = getPar0(nfsFits_gps)$Par) -->
<!-- #plot(MIfit_argos) -->
<!-- #viterbi(MIfit_argos[]) -->
<!-- MIpool_argos <- MIpool(MIfit_argos[[2]]) -->
<!-- plot(MIpool_argos) -->
<!-- # MIpool_argos$Par$states -->

<!-- sum(MIpool_argos$Par$states == viterbi(HMM_gps_45)[which(HMM_gps_45$data$ID=="T172062")])/nrow(sub_argos[[1]]) -->

<!-- ```{r} -->

<!-- #### sub argos track with fix par data.table ###########################~### -->
<!-- sub_argos <- tracks_argos %>% -->
<!--     filter(ID == "T172062") %>% -->
<!--     # filter(loc_class %in% c("3","2", "1", "A","B")) %>% -->
<!--     list() -->

<!-- predTime <- lapply(sub_argos, function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->

<!-- # define priors -->
<!-- prior <-  function(p) { -->
<!--       dnorm(p[2], -4, 0.1, log = TRUE)  # beta -->
<!-- } -->
<!-- # calculate known error between argos and GPS # -->
<!-- { -->
<!--   library(data.table) -->
<!--   data <- data.frame(ID = prep_gps_45$ID, -->
<!--                      time = prep_gps_45$time, -->
<!--                      x_gps = prep_gps_45$x, y_gps = prep_gps_45$y, -->
<!--                      x_argos = prep_argos_45$x, y_argos = prep_argos_45$y) %>% -->
<!--     mutate(d_loc = sqrt((x_argos-x_gps)^2+(y_argos-y_gps)^2), -->
<!--            dx = abs(x_argos-x_gps), dy = abs(y_argos-y_gps)) %>% -->
<!--     setDT() -->
<!--   tracks_argos_dt <-tracks_argos %>% -->
<!--     dplyr::select(ID, time, loc_class) %>% -->
<!--     setDT() -->
<!--   # set keys -->
<!--   setkey(data, ID, time) -->
<!--   setkey(tracks_argos_dt, ID, time) -->
<!--   # rolling join -->
<!--   data.df <- as.data.frame(tracks_argos_dt[data, roll = TRUE]) -->
<!--   # void large gaps -->
<!--   data.df$d_loc[is.na(prep_argos_45$step)] <- NA -->
<!--   data.df$dx[is.na(prep_argos_45$step)] <- NA -->
<!--   data.df$dy[is.na(prep_argos_45$step)] <- NA -->
<!--   # summarise -->
<!--   data.df %>% group_by(loc_class) %>% -->
<!--     summarise(mean_d_loc = mean(d_loc, na.rm = T), -->
<!--               sd_d_loc = sd(d_loc, na.rm = T), -->
<!--               mean_dx = mean(dx, na.rm = T), -->
<!--               mean_dy = mean(dy, na.rm = T)) -->
<!-- } -->
<!-- fixPar <- c(log(767), log(969), log(1200),   #x -->
<!--             log(1831),log(1811),log(1972), -->
<!--             log(717), log(1343), log(1150),   #y -->
<!--             log(1666),log(1448),log(1882), -->
<!--             NA, NA) # sgima, beta -->

<!-- # fit -->
<!-- argos_45_crwOut_1trk_fx <- -->
<!--   crawlWrap(tracks_argos_ls[[1]], -->
<!--             retryFits = 200, retrySD = 5, -->
<!--             Time.name = "time", -->
<!--             err.model = err.model, -->
<!--             prior = prior, -->
<!--             fixPar = fixPar, -->
<!--             predTime = predTime[[1]]) -->
<!-- # view -->
<!-- argos_45_crwOut_1trk_fx$crwFits$T172062 -->
<!-- plot(argos_45_crwOut_1trk_fx) -->

<!-- ``` -->

<!-- # nfsFits <- MIfitHMM(argos_45_crwOut_1trk, nSims = 1, fit = F) -->
<!-- MIfit_argos <- MIfitHMM(argos_45_crwOut_1trk_fx, nSims = 500, fit = T, -->
<!--                         nbStates = 2, dist = dist, ncores = ncores, -->
<!--                         Par0 = getPar0(nfsFits_gps)$Par) -->
<!-- #plot(MIfit_argos) -->
<!-- #viterbi(MIfit_argos[]) -->
<!-- MIpool_argos <- MIpool(MIfit_argos[[2]]) -->
<!-- plot(MIpool_argos) -->
<!-- # MIpool_argos$Par$states -->

<!-- sum(MIpool_argos$Par$states == viterbi(HMM_gps_45)[which(HMM_gps_45$data$ID=="T172062")])/nrow(sub_argos[[1]]) -->


<!-- # sub argos track w  fix par ########### -->
<!-- sub_argos <- tracks_argos %>%  -->
<!--     filter(ID == "T172062") %>%  -->
<!--     list() -->

<!-- predTime <- lapply(sub_argos, function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->

<!-- # define priors -->
<!-- prior <-  function(p) {  -->
<!--       dnorm(p[1], log(250), 0.2, log = TRUE) +  # 3 -->
<!--       dnorm(p[2], log(500), 0.2, log = TRUE) +  # 2 -->
<!--       dnorm(p[3], log(100), 0.2, log = TRUE) +  # 1 -->
<!--        # dnorm(p[4], log(2000), 4, log = TRUE) +  # 0 -->
<!--        # dnorm(p[5], log(2000), 4, log = TRUE) +  # A -->
<!--        # dnorm(p[6], log(2000), 4, log = TRUE) +  # B -->
<!--       # skip p[7] as we won't provide a prior for sigma -->
<!--       dnorm(p[5], 0, 0.2, log = TRUE)  # beta -->
<!-- } -->

<!-- fixPar <- c(NA, NA, NA,   #x -->
<!--             log(2500), log(2500), log(2500),   -->
<!--             NA, NA, NA,  #y -->
<!--             log(2500), log(2500), log(2500),  -->
<!--             NA, NA) # sgima, beta -->

<!-- # define error model -->
<!-- err.model <- list(x = ~ loc_class - 1, y = ~ loc_class - 1) -->

<!-- argos_45_crwOut_1trk <-   -->
<!--   crawl::crwMLE(data = sub_argos[[1]], -->
<!--             retryFits = 50, attempts = 50,  -->
<!--             Time.name = "time", -->
<!--             err.model = err.model, -->
<!--             prior = prior, fixPar = fixPar) -->
<!--   # [which(track_T172062$loc_class %in% c("3","2", "0", "A"))]) -->
<!-- argos_45_crwOut_1trk$crwFits$T172062 -->
<!-- plot(argos_45_crwOut_1trk) -->

<!-- nfsFits <- MIfitHMM(argos_45_crwOut_1trk, nSims = 3,  -->
<!--                      nbStates = 2, dist = dist, Par0 = Par0, fit = T) -->
<!-- plot(nfsFits) -->




<!--  gps_45_crwOut <- crawlWrap(tracks_gps, -->
<!--   timeStep = "45 min", Time.name = "time", -->
<!--   predTime = predTime) -->
<!-- gpsFits <- MIfitHMM(gps_45_crwOut, nSims = 1, fit = F) -->
<!-- ``` -->


## Bonus 
<!-- ### Dealing with location error and irregular time -->
<!-- Thus far, we have been using exclusively the GPS data, which can be assumed to have a negligible error in most applications. However, in many marine systems, we may obtain ARGOS locations, which can have highly variable location error on the order of hundreds of meters to hundreds of km. In addition, ARGOS data often provides location estimates in very irregular time intervals. `crawlWrap` can be used not only to predict impute missing data, but also to predict location when faced with high location error and irregular time-series. -->

<!-- ```{r filter_argos} -->
<!-- # filter argos data -->
<!-- tracks_argos <- filter(tracks_proj, loc_class != "GPS") %>% -->
<!--   # calculate dime difference -->
<!--   mutate(dt = ifelse(ID == lead(ID), -->
<!--                      difftime(lead(time), time, units = "mins"), NA), -->
<!--          # define location class factor levels   -->
<!--          loc_class = factor(loc_class,       -->
<!--                             levels = c(3, 2, 1, 0, "A", "B"))) -->
<!-- ``` -->
<!-- Note: It is possible to include both GPS and ARGOS data in one model (you would define the levels as such: `levels = c("GPS", 3, 2, 1, 0, "A", "B")'. However, for this example, we will illustrate the more difficult scenario using only ARGOS data and use the GPS data as a measure of model performance. -->
<!-- Visualize ARGOS tracks. -->

<!-- ```{r plot_original_data, message=FALSE} -->
<!-- # convert to lines and plot using tmap -->
<!-- tracks_argos %>% -->
<!--   group_by(ID) %>% -->
<!--   summarise(do_union = FALSE) %>% -->
<!--   st_cast("LINESTRING") %>% -->
<!--   tm_shape() + -->
<!--   tm_sf(col = "ID", palette = "Dark2") -->
<!-- ``` -->

<!-- Notice how much more noise there is in this data compared to the gps tracks. In addition, it looks like there are at least several outlier points. We can address most of these using a coarse speed filter. However, before we can calculate speed ($\frac{\Delta dist}{\Delta t}$), we must address the duplicate time-stamps (since we cannot divide by 0 to calculate speed). It is often not possible to reliably identify which record is more accurate to discard. Therefore, it's best to retain as as much data and offset duplicate times slightly. We will first offset duplicate times by adding 10s for each consecutive row with a `dt == 0`. -->

<!-- <!-- MAM: why 10 sec? Is there are reason not to go to one sec? --> -->

<!-- ```{r offset_duplicate_times, message=FALSE} -->
<!-- # 1) count the run length of each time step using rle -->
<!-- run_length <- rle(tracks_argos$dt)$lengths -->
<!-- # 2) create a sequence of 1:run_length for each time step -->
<!-- run_seqence <- sequence(run_length) -->
<!-- # 3) discount each time step that's not a duplicate by multiplying by 0 -->
<!-- run_seqence <- run_seqence*(tracks_argos$dt==0) -->
<!-- # 4) lag run_sequence by one row and replace the first value by 0, -->
<!-- # so that we iterate each time that is a duplicate of the previous row -->
<!-- tracks_argos$duplicate_count <- replace_na(lag(run_seqence), 0) -->
<!-- # offset duplicate times by 10s -->
<!-- tracks_argos <- -->
<!--   tracks_argos %>% -->
<!--   mutate(time = time + 10*duplicate_count, -->
<!--          # recalculate time difference -->
<!--          dt = ifelse(ID == lead(ID), -->
<!--     difftime(lead(time), time, units = "mins"), NA -->
<!--   )) -->

<!-- # last we ensure there are no identical times -->
<!-- sum(tracks_argos$time == lead(tracks_argos$time), na.rm = TRUE) -->
<!-- ``` -->

<!-- <!-- MAM: why are you using a speed filter? Aren't you using crawl to handle the error? You might want to explain why. --> -->

<!-- Now, we can apply a speed filter to remove locations that are faster than some threshold -- in this case we will exclude any locations $>10$ m/s from the previous location. -->

<!-- ```{r speed_filter, message=FALSE} -->
<!-- # distance from previous location -->
<!-- delta_dist <- st_distance(tracks_argos, lag(tracks_argos), by_element=TRUE) -->
<!-- # time from previous location -->
<!-- delta_t <- set_units(lag(tracks_argos$dt), "min") -->
<!-- # calculate speed -->
<!-- tracks_argos$spd <- delta_dist/delta_t -->

<!-- # filter speed -->
<!-- tracks_argos <- tracks_argos %>% -->
<!--   filter(spd < set_units(10, "m/s")) -->

<!-- # convert to lines and plot -->
<!-- tracks_argos %>% group_by(ID) %>% -->
<!--   summarise(do_union = F) %>% -->
<!--   st_cast("LINESTRING") %>% -->
<!--      tm_shape()+ -->
<!--    tm_lines(col = "ID", palette = "Dark2") -->
<!-- ``` -->

<!-- Already looking much better. -->

<!-- location accuracy (ignoring duplicate locations) -->
<!-- ```{r loc_class_freq} -->
<!-- # identify proportion of each location class -->
<!-- tracks_argos %>% -->
<!--   filter(dt > 0) %>% -->
<!--   {table(.$loc_class)/nrow(tracks_argos)} -->
<!-- ``` -->

<!-- we have to deal with location error, irregular time, and missing locations. The `crawl` model that we fit earlier can be extended to predict tracks from irregular data with location error. In this section, we will cover using `crawlWrap` to amputate regular locations when faced with more difficult data (e.g., ARGOS) and fitting an HMM to multiple imputed data. -->

<!-- <!-- MAM: here you have to put a bit more info on crawl. I.e. it's a state space models that handle error, etc. --> -->

<!-- First let's identify a resolution to work at if only obtained ARGOS data. -->

<!-- ```{r select_ARGOS_resolution} -->
<!-- # visualise time differences -->
<!-- hist(tracks_argos$dt[tracks_argos$dt<180], 32, -->
<!--      main = NA, xlab = "Time difference (min)") -->

<!-- # summarise track dt -->
<!-- tracks_argos %>%  -->
<!--   st_drop_geometry() %>%  -->
<!--   group_by(ID) %>%  -->
<!--   summarise(p_NA_10m = p_na(time, n_loc, 10),  # 10 min  -->
<!--             p_NA_20m = p_na(time, n_loc, 20),  # 20 min  -->
<!--             p_NA_30m = p_na(time, n_loc, 30),  # 30 min  -->
<!--             p_NA_45m = p_na(time, n_loc, 45),  # 45 min  -->
<!--             p_NA_60m = p_na(time, n_loc, 60))  # 60 min  -->
<!--             # p_NA_60m = p_na(time, n_loc, 90),  # 90 min  -->
<!--             # p_NA_60m = p_na(time, n_loc, 120)) # 120 min  -->
<!-- ``` -->

<!-- In this section, we will use 45 min as a trade-off between higher resolution and minimising data gaps. -->

<!-- First, we will split the ARGOS tracks into a list by ID, and identify the times in which to predict locations. -->
<!-- ```{r} -->
<!-- # split ARGOS tracks into list by ID -->
<!-- tracks_argos_ls <- tracks_argos %>% -->
<!--   mutate(x = st_coordinates(tracks_argos)[,"X"], -->
<!--          y = st_coordinates(tracks_argos)[,"Y"]) %>% -->
<!--   st_drop_geometry() %>% -->
<!--     split(.,.$ID) -->
<!-- # define times to predict for easier comparison between ARGOS and GPS tracks -->
<!-- predTime <- lapply(tracks_argos_ls, function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->
<!-- ``` -->

<!-- Next, we will define the error model for `crawl`, which describes the longitudinal and latitudinal location error associated with the location quality classes. -->
<!-- ```{r define_error_model} -->
<!-- # define error model -->
<!-- err.model <- list(x = ~ loc_class - 1, y = ~ loc_class - 1) -->
<!-- ``` -->

<!-- The `crawl` tutorial suggests that users define prior distributions to optimize the fit and increase the model’s ability to converge with limited/challenging data while providing the model flexibility. Here, we provide a normal distribution of the log-transformed error for each of the ARGOS error classes. The tutorial also suggest users rely on the prior distribution for the beta parameter centered on -4 (smoother fit) and, if needed, fix the beta parameter to -4 (see `crawl` tutorial [HERE](https://jmlondon.github.io/crawl-workshop/crawl-practical.html#predicting-a-movement-track)). -->

<!-- ```{r define_argos_priors, message=FALSE, eval = T} -->
<!-- # define priors -->
<!-- prior <- function(p) { -->
<!--   dnorm(p[1], log(250),  0.2, log = TRUE) +  # 3 -->
<!--   dnorm(p[2], log(500),  0.2, log = TRUE) +  # 2 -->
<!--   dnorm(p[3], log(1500), 0.2, log = TRUE) +  # 1 -->
<!--   dnorm(p[4], log(2500), 0.4, log = TRUE) +  # 0 -->
<!--   dnorm(p[5], log(2500), 0.4, log = TRUE) +  # A -->
<!--   dnorm(p[6], log(2500), 0.4, log = TRUE) +  # B -->
<!--   # skip p[7] as we won't provide a prior for sigma -->
<!--   dnorm(p[8], -4, 3, log = TRUE)  # beta parameter -->
<!-- } -->
<!-- ``` -->

<!-- Fit `crawl` model to ARGOS tracks -->
<!-- ```{r fit_45_min_crawl_to_argos_tracks, message=FALSE, cache=TRUE} -->
<!-- # fit crawl model and predict locations at 45 min time steps -->
<!-- set.seed(1) -->
<!-- crwOut_argos_45 <- crawlWrap(tracks_argos, -->
<!--   timeStep = "45 min", -->
<!--   retryFits = 1, Time.name = "time", -->
<!--   err.model = err.model, -->
<!--   prior = prior, -->
<!--   predTime = predTime) -->
<!-- # check that each track converged (0 = converged) -->
<!-- sapply(crwOut_argos_45$crwFits, function(x)x$convergence) -->
<!-- plot(crwOut_argos_45, ask = FALSE) -->
<!-- # convert to data.frame and extract predicted locations -->
<!-- crw_argos_45 <- data.frame(crwOut_argos_45$crwPredict) %>% -->
<!--   filter(locType == "p") %>% -->
<!--   dplyr::select(mu.x, mu.y, time, ID, loc_class) %>% -->
<!--   dplyr::rename(x = "mu.x", y = "mu.y") -->
<!-- ``` -->
<!-- <!-- MAM: I get some warnings here, that something is going on --> -->

<!-- For comparison, we will also use `crawlWrap` to interpolate GPS data at a 45 min frequency/ -->

<!-- ```{r fit_45_min_crawl_to_gps_tracks, message=FALSE} -->
<!-- # fit crawl model and predict locations at 45 min time steps for GPS data -->
<!-- set.seed(1) -->
<!-- crwOut_gps_45 <- crawlWrap(obsData = tracks_gps, timeStep = "45 mins", -->
<!--                         predTime = predTime)  -->

<!-- # check that each track converged (0 = converged) -->
<!-- sapply(crwOut_gps_45$crwFits, function(x)x$convergence) -->
<!-- # convert to data.frame and extract predicted locations -->
<!-- crw_gps_45 <- data.frame(crwOut_gps_45$crwPredict) %>% -->
<!--   filter(locType == "p") %>% -->
<!--   dplyr::select(mu.x, mu.y, time, ID) %>% -->
<!--   dplyr::rename(x = "mu.x", y = "mu.y") -->

<!-- # compare estimated tracks -->
<!-- filter(crw_argos_45, ID=="T172062")  %>% -->
<!-- plot(y~x, data=., type = 'l', col = 'red', asp = 1) -->
<!-- filter(crw_gps_45, ID=="T172062") %>% -->
<!-- points(y~x, data=., type = 'l') -->

<!-- ``` -->

<!-- <!-- MAM: I get some warnings here, that something is going on --> -->

<!-- We see that there is some over lap between the ARGOS (red) and GPS (black) tracks at a 45 min resolution. However, there are some sections where the ARGOS track cuts straight lines through sections where there is variability in the GPS track. -->

<!-- Let's try to fit an HMM to the interpolated ARGOS tracks. -->
<!-- ```{r prep_ARGOS_tracks_and_fit_basic_HMM, message = FALSE, cache=T} -->
<!-- # prep tracks -->
<!-- prep_argos_45 <- prepData(crw_argos_45, type = "UTM") -->
<!-- prep_gps_45 <- prepData(crw_gps_45, type = "UTM") -->

<!-- # setup model -->
<!-- dist <- list(step = "gamma", angle = "vm") -->
<!-- # Setting up the starting values -->
<!-- mu0 <- c(1000, 3000) # mu step -->
<!-- sigma0 <- mu0      # Sd step -->
<!-- kappa0 <- c(1, 3)    # kappa angle -->
<!-- Par0 <- list(step = c(mu0, sigma0), angle = kappa0) -->

<!-- # Fit a 2 state HMM for 45 min ARGOS and GPS tracks -->
<!-- set.seed(1) -->
<!-- HMM_argos_45_basic <- fitHMM(prep_argos_45, nbState = 2, dist = dist, Par0 = Par0) -->
<!-- HMM_gps_45_basic <- fitHMM(prep_gps_45, nbState = 2, dist = dist, Par0 = Par0) -->

<!-- plot(HMM_argos_45_basic, animals = "T172062", ask = F) -->
<!-- plot(HMM_gps_45_basic, animals = "T172062", ask = F) -->

<!-- # compare predicted states -->
<!-- sum(viterbi(HMM_argos_45_basic) == viterbi(HMM_gps_45_basic))/nrow(prep_argos_45) -->
<!-- ``` -->

<!-- The interpolated GPS track seems to fit, however the model had some issues fitting the ARGOS data. The ARGOS model is clearly defining all the interpolated segments as state 1 and the observed locations as state 2. Further, $<50/%$ of the predicted states from the ARGOS model are the same as the GPS model. I suspect the issue may be due to the large gaps where the interpolated track is basically linear. Indeed, in the GPS HMM, state 1 seems to primarily be classifying the straight interpolated sections as state 1 and the rest as state 2. We can try to address this by voiding large gaps using the `prepData_NAGaps` function we defined earlier. In this case, we will voiding gaps $>180$ min -->

<!-- ```{r prep_data_and_void_gaps} -->
<!-- # prep 45 min ARGOS data and void large gaps -->
<!-- prep_argos_45 <- prepData_NAGaps(track_list = tracks_argos_ls, tracks_crw = crw_argos_45, res = 45, max_gap = 180, type = "UTM") -->

<!-- # prep 45 min gps data and void large gaps -->
<!-- prep_gps_45 <- prepData_NAGaps(track_list = tracks_gps_ls, tracks_crw = crw_gps_45, res = 45, max_gap = 180, type = "UTM") -->
<!-- ``` -->

<!-- Now, let's try to fit the same HMM as above to this data with large gaps voided. -->

<!-- ```{r voided_crawl_HMM_fitHMM_argos, message=FALSE} -->
<!-- set.seed(1) -->
<!-- # Fit a 2 state HMM for 45 min ARGOS and GPS tracks -->
<!-- HMM_argos_45 <- fitHMM(prep_argos_45, nbState = 2, dist = dist, Par0 = Par0) -->
<!-- HMM_gps_45 <- fitHMM(prep_gps_45, nbState = 2, dist = dist, Par0 = Par0) -->

<!-- plot(HMM_argos_45, animals = "T172062", ask = "F") -->
<!-- plot(HMM_gps_45, animals = "T172062", ask = "F") -->
<!-- # compare new and original GPS model predicted states -->
<!-- sum(viterbi(HMM_gps_45_basic) == viterbi(HMM_gps_45))/nrow(prep_argos_45) -->
<!-- # compare new and original GPS model predicted states -->
<!-- sum(viterbi(HMM_argos_45) == viterbi(HMM_gps_45))/nrow(prep_argos_45) -->
<!-- ``` -->

<!-- Both data sets seem to fit easily. There isn't a large change between this GPS model and the previous one (without voiding large gaps); $94/%$ of the predicted states are the same. However, the overlap between the ARGOS and GPS models is much higher than previously ($74\%$), suggesting the ARGOS model with voided gaps is significantly improved. However, there is still a notable discrepancy between the ARGOS and the GPS HMMs. -->

<!-- #### Multiple imputation -->

<!-- ----- WORK IN PROGRESS ------ -->
<!-- first, fit MI to GPS data for starting parameters -->
<!-- ```{r} -->
<!-- # fit crawl to 1 gpstrack and predict locations at 45 min time stepstracks <- -->
<!-- cwr_gps_sub <- tracks_gps %>% -->
<!--   filter(ID == "T172062") -->

<!-- predTime <- lapply(split(cwr_gps_sub,cwr_gps_sub$ID), function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->

<!-- # fit crawl -->
<!-- set.seed(1) -->
<!-- crwOut_gps_T172062 <- -->
<!--   crawlWrap(cwr_gps_sub, -->
<!--   retryFits = 1, Time.name = "time", -->
<!--   predTime = predTime) -->
<!-- crwOut_gps_T172062$crwFits$T172062 -->

<!-- # define starting paraeters -->
<!-- mu0 <- c(1000, 3000) # mu step -->
<!-- sigma0 <- mu0        # sd step -->
<!-- kappa0 <- c(1, 3)    # kappa angle -->
<!-- Par0 <- list(step = c(mu0, sigma0), angle = kappa0) -->

<!-- # fit multiple imputation HMM to subset to GPS tracks -->
<!-- nfsFits_gps <- MIfitHMM(crwOut_gps_T172062, nSims = 10, -->
<!--                      nbStates = 2, dist = dist, Par0 = Par0, fit = T) -->
<!-- plot(nfsFits_gps, ask = F) -->
<!-- ``` -->

<!-- - working on subset track -  -->
<!-- ```{r subset_argos_T172062} -->
<!-- # subset  -->
<!-- sub_argos <- tracks_argos %>% -->
<!--     filter(ID == "T172062") %>% -->
<!--     list() -->
<!-- # recalculate predTime -->
<!-- predTime <- lapply(sub_argos, function(x) -->
<!--   seq(first(x$time), last(x$time), "45 min")) -->
<!-- ``` -->

<!-- `crawl` works best when there is either low location error (e.g., GPS data), when the animal movement is significantly greater than the location error, or there is a large amount of data. When any/all of these criteria are met, we can provide priors as follows: -->
<!-- ```{r argos_priors_when_good, message=FALSE, eval = FALSE} -->
<!-- # define priors -->
<!-- prior <- function(p) { -->
<!--   dnorm(p[1], log(250),  0.2, log = TRUE) +  # 3 -->
<!--   dnorm(p[2], log(500),  0.2, log = TRUE) +  # 2 -->
<!--   dnorm(p[3], log(1500), 0.2, log = TRUE) +  # 1 -->
<!--   dnorm(p[4], log(2500), 0.4, log = TRUE) +  # 0 -->
<!--   dnorm(p[5], log(2500), 0.4, log = TRUE) +  # A -->
<!--   dnorm(p[6], log(2500), 0.4, log = TRUE) +  # B -->
<!--   # skip p[7] as we won't provide a prior for sigma -->
<!--   dnorm(p[8], -4, 0, log = TRUE)  # beta parameter -->
<!-- } -->
<!-- ``` -->
<!-- However, in our case, the location error is often larger than narwhals' movement over a 45 min period, so we will actually fix the location error estimates, provide a prior for beta (a measure of autocorrelation in narwhal movement), and allow the model to estimate sigma without any priors. -->
<!-- ```{r define_sub_argos_priors, message=FALSE} -->
<!-- # define priors -->
<!-- prior <-  function(p) { -->
<!--       # skip p[1] as we won't provide a prior for sigma -->
<!--       dnorm(p[2], -4, 0.1, log = TRUE)  # beta parameter -->
<!-- } -->
<!-- ``` -->

<!-- calculate known error between argos and GPS to get Fix parameters for error model. -->
<!-- ```{r calculate_sub_argos_fix_par, message=FALSE} -->
<!-- # combine GPS and ARGOS narwhal locations  -->
<!-- data <- data.frame(ID = prep_gps_45$ID, -->
<!--                    time = prep_gps_45$time, -->
<!--                    x_gps = prep_gps_45$x, y_gps = prep_gps_45$y, -->
<!--                    x_argos = prep_argos_45$x, y_argos = prep_argos_45$y) %>% -->
<!--   # calculate difference between GPS and ARGOS locations -->
<!--   mutate(#d_loc = sqrt((x_argos-x_gps)^2+(y_argos-y_gps)^2), -->
<!--          dx = abs(x_argos-x_gps), dy = abs(y_argos-y_gps)) %>% -->
<!--   setDT() # convert to data.table -->

<!-- # Select ARGOS columns to merge and convert track to data.table -->
<!-- tracks_argos_dt <-tracks_argos %>% -->
<!--   dplyr::select(ID, time, loc_class) %>% -->
<!--   setDT() -->

<!-- # set keys to join -->
<!-- setkey(data, ID, time) -->
<!-- setkey(tracks_argos_dt, ID, time) -->

<!-- # rolling join -->
<!-- data.df <- as.data.frame(tracks_argos_dt[data, roll = TRUE]) -->

<!-- # void large gaps so simulated locations do not skew model error -->
<!-- # data.df$d_loc[is.na(prep_argos_45$step)] <- NA -->
<!-- data.df$dx[is.na(prep_argos_45$step)] <- NA -->
<!-- data.df$dy[is.na(prep_argos_45$step)] <- NA -->

<!-- # calculate mean x and y error for each location classusing summarise -->
<!-- data.df %>%  -->
<!--   group_by(loc_class) %>% # group by location class -->
<!--   summarise(#mean_d_loc = mean(d_loc, na.rm = T), -->
<!--             #sd_d_loc = sd(d_loc, na.rm = T), -->
<!--             mean_dx = mean(dx, na.rm = T), -->
<!--             mean_dy = mean(dy, na.rm = T)) -->

<!-- # define fixPar using abover  -->
<!-- fixPar <- c(log(767), log(969), log(1200), # x 3,2,1  -->
<!--             log(1831),log(1811),log(1972), # x 0,A,B -->
<!--             log(717), log(1343), log(1150),# y 3,2,1  -->
<!--             log(1666),log(1448),log(1882), # y 0,A,B -->
<!--             NA, NA) # sgima, beta (to be estimated) -->
<!-- ``` -->

<!-- fit crawl model to the first narwhal -->
<!-- ```{r calculate_define_sub_argos_priors, message=FALSE, eval=TRUE, cache=T} -->
<!-- # fit -->
<!-- set.seed(1) -->
<!-- argos_45_crwOut_1trk_fx <- -->
<!--   crawlWrap(tracks_argos_ls[[1]], -->
<!--             retryFits = 100, retrySD = 5, -->
<!--             Time.name = "time", -->
<!--             err.model = err.model, -->
<!--             prior = prior, -->
<!--             fixPar = fixPar, -->
<!--             predTime = predTime[[1]]) -->
<!-- # view -->
<!-- argos_45_crwOut_1trk_fx$crwFits$T172062 -->
<!-- plot(argos_45_crwOut_1trk_fx) -->
<!-- ``` -->

<!-- fit multiple imputation HMM -->
<!-- ```{r MIfitHMM_argos_priors, message=FALSE, cache=T} -->
<!-- # nfsFits <- MIfitHMM(argos_45_crwOut_1trk, nSims = 1, fit = F) -->
<!-- set.seed(1) -->
<!-- MIfit_argos <- MIfitHMM(argos_45_crwOut_1trk_fx, nSims = 100, fit = T, -->
<!--                         nbStates = 2, dist = dist, ncores = ncores, -->
<!--                         Par0 = getPar0(nfsFits_gps)$Par) -->
<!-- #pool results  -->
<!-- MIpool_argos <- MIpool(MIfit_argos[[2]]) -->
<!-- # plot pooled data -->
<!-- plot(MIpool_argos, ask = F) -->

<!-- sum(MIpool_argos$Par$states == viterbi(HMM_gps_45)[which(HMM_gps_45$data$ID=="T172062")])/nrow(sub_argos[[1]]) -->
<!-- ``` -->
<!-- $70\%$ overlap in predicted states -->

<!-- ```{r loop_crawl_seed} -->
<!-- error <- T -->

<!-- i <- 5 -->
<!-- while(error){ -->
<!--   print(i) -->
<!--   tryCatch({ -->
<!--         set.seed(i) # crawl can fail to fit periodically, so I recommend always setting a seed  -->
<!--         # fit crawl -->
<!--         crw_gps_10 <- crawlWrap(obsData = tracks_gps, timeStep = "10 mins") -->
<!--         # view that all parameters were propperly estimated  -->
<!--         n.work <- crw_gps_10$crwFits %>%  -->
<!--           lapply(function(x){ -->
<!--             x[c("par","se","ci")] %>%  # get estimated values  -->
<!--             unlist() %>%  # unlist -->
<!--               is.nan() %>%  # identify values that failed to estimate -->
<!--               sum() == 0 # count failed estimates and ensure there are 0 -->
<!--           }) %>%  -->
<!--           unlist() %>%  -->
<!--           sum() -->
<!--         if(n.work !=3){ -->
<!--           crw_gps_10 <- NULL -->
<!--           i <- i + 1 -->
<!--         } else { -->
<!--           error <- F -->
<!--         } -->
<!--   }, -->
<!--       error = function(e){} -->
<!--   ) -->
<!-- } -->
<!-- ``` -->

<!-- e -->
