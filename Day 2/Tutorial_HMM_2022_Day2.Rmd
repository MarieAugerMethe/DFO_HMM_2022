---
title: "Hidden Markov Models: Missing data and multiple data streams"
editor_options:
  chunk_output_type: console
output:
  html_document:
    number_sections: true
  pdf_document: 
    number_sections: true
---

# Tutorial goals and set up

## objectives

-   Dealing irregular locations,

-   time gaps,

-   including diving covariates

-   narwhal data

# import data

First, we'll setup the workspace with required packages

```{r message=FALSE}
library(momentuHMM)
library(dplyr)
library(tidyr)
library(lubridate)
library(adehabitatLT)
library(sf)
library(tmap)
library(terra)
library(units)
library(stringr)
library(diveMove)
require("conicfit")
require("car")
library(corrplot)  # Paerson's correlation matrix using cor()
```

For simplicity, we will also only look at the data for the month of August, 2017.
```{r import tracks, message=FALSE}
tracks <- read.csv("data/tracks.csv") %>%
  filter(!is.na(x) & !is.na(y)) %>% # remove missing locations
  mutate(
    time = ymd_hms(time), # define time
    loc_class = factor(loc_class, # define location class factor levels
      levels = c("GPS", 3, 2, 1, 0, "A", "B"))) %>% 
  # remove identical records
  filter(!(time == lag(time) & x == lag(x) & y == lag(y) & loc_class == lag(loc_class)),
  # filter only the month of august
  month(time) == 8, day(time) > 7,  day(time) <= 14)

```

The classic HMM assumes the observation data is in discrete time and that there is no missing data in the predictor variables

```{r calc dt}
# calculate time difference between locations
tracks <- tracks %>%
  mutate(dt = ifelse(ID == lead(ID), # If next data row is same individual
    difftime(lead(time), time, units = "mins"), NA
  )) # calculate time difference

hist(tracks$dt, 1000, main = NA, xlab = "Time difference (min)")
```

Next, we'll convert the data to a spatial dataset using the `sf` package and plot the data.
First, we define the coordinate reference system of the original data (in this case WGS84, which is defined by the EPSG code `4326`). Next, we will project the data into NAD83(CSRS) UTM zone 21N (EPSG:2962), which will projected the coordinates in meter units with minimal distortion for this data set. 

```{r define projection, message=FALSE}
tracks <- tracks %>%
  st_as_sf(coords = c("x", "y")) %>% # converts to an sf object
  st_set_crs(4326) %>% # define CRS
  st_transform(2962) # reproject data to a UTM
```

Now, we can map the data using the `tmap` package to visualise what it looks like.
```{r plot original data, message=FALSE}
# convert to lines and plot using tmap
tracks %>% 
  group_by(ID) %>% 
  summarise(do_union = F) %>% 
  st_cast("LINESTRING") %>% 
  tm_shape() + 
  tm_sf(col = "ID", palette = "Dark2")
```

It looks like there are at least several outlier points. We can address most of these using a coarse speed filter. However, before we can calculate speed ($\frac{\Delta dist}{\Delta t}$), we must address the duplicate time-stamps (since we cannot divide by 0 to calculate speed). It is often not possible to reliably identify which record is more accurate to discard. Therefore, it's best to retain as as much data and offset duplicate times slightly. We will first offset duplicate times by adding 10s for each consecutive row with a `dt == 0`.

```{r offset duplicate times, message=FALSE}
# first, we count the run length of each time step using rle
run_length <- rle(tracks$dt)$lengths
# second, we create a sequence of 1:run_length for each time step
run_seqence <- sequence(run_length)
# third, we discount each time step that's not a duplicate by multiplying by 0
run_seqence <- run_seqence*(tracks$dt==0)
# last, we lag run_sequence by one row and replace the first value by 0,
# so that we itterate each time that is a duplicate of the previous row
tracks$duplicate_count <- replace_na(lag(run_seqence), 0)
# offset duplicate times by 10s
tracks <- 
  tracks %>%
  mutate(time = time + 10*duplicate_count,
         # recalculate time difference
         dt = ifelse(ID == lead(ID), 
    difftime(lead(time), time, units = "mins"), NA
  ))

# last we ensure there are no identical times
sum(tracks$time == lead(tracks$time), na.rm = T)
```

Now, we can apply a speed filter to remove locations that are faster than some threshold -- in this case we will exclude any locations $>10$ m/s from the previous location.

```{r speed filter, message=FALSE}
# distance from previous location 
delta_dist <- st_distance(tracks, lag(tracks), by_element=TRUE)
# time from previous location
delta_t <- set_units(lag(tracks$dt), "min") 
# calculate speed
tracks$spd <- delta_dist/delta_t

# filter speed
tracks <- tracks %>% 
  filter(spd < set_units(10, "m/s"))

# convert to lines and plot
tracks %>% group_by(ID) %>% 
  summarise(do_union = F) %>% 
  st_cast("LINESTRING") %>% 
     tm_shape()+
   tm_lines(col = "ID", palette = "Dark2")
```
Already looking much better.

For the first part of this tutorial, we'll use only the fastloc GPS data so we don't have to deal with location error. 

```{r filter and plot gps data, message=FALSE}
# filter GPS locations only
tracks_gps <- tracks %>% 
  filter(loc_class=="GPS")

# plot GPS
tracks_gps %>% 
  group_by(ID) %>% 
  summarise(do_union = F) %>% 
  st_cast("LINESTRING") %>% 
     tm_shape() +
   tm_lines(col = "ID", palette = "Dark2")
```
We lose some data, particularly near the end of the tracks, but we will integrate ARGOS locations later in this tutorial.

## selecting a time interval for the HMH
there are two key decisions we must make, the temporal resolution to use, and how to address data gaps. The desired resolution depends predominantly on the biological question you are asking as different behaviours and biological processes occur at different spatial and temporal scales (e.g. seasonal migration, daily movement between foraging and resting grounds, and fine scale foraging decisions). Generally, higher resolution data is preferred as it has more information, however it is possible to have too-high of a resolution wherein information from fine-scale variability drowns out the signal from coarse-scale patterns of interest (e.g., seasonal migration). In this case, we will be linking the movement data with high resolution (75 s) dive data to look at finer-scale behaviours (on the order of a few hours). My rule of thumb, is that you want 3-50 data points per behaviour. For behaviours spanning several hours, that roughly corresponds to a desired resolution between 2 min and 60 min. 

Let's see what resolutions may be possible in the data by looking at the most frequent time gaps.
```{r calc and view track dt}
# identify the most frequent dt
tracks_gps %>% 
  {table(.$dt)} %>% 
  sort(decreasing = T) %>% 
  head()
# visualise time differences
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)")
hist(tracks_gps$dt, 1000, main = NA, xlab = "Time difference (min)", xlim = c(0,100))
```
We see that that the most frequent time gap is 10 min, followed by 1, 11, and 12 min. We also see the majority of the gaps are < 60 min, however some are in excess of 600 min. Although it may be possible to use 1 or 2 min resolution data, we will have to address the data gaps. Frequent and large data gaps can be difficult to handle, especially as the number of missing data points approaches or exceeds the existing data; we really want to avoid this. Let's examine the potential data structure at different resolutions for the different animals.
```{r track resolution proportion NA}
# make function to estimate proportion of missing location 
p_na <- function(t_0, t_max, n_loc, resolution) {
  max_n_loc <- length(seq(t_0, t_max, by = as.difftime(resolution, units = "mins")))
  n_NA <- max_n_loc - n_loc
  n_NA / max_n_loc
}

# summarise tracks
 track_summary <-
    tracks_gps %>% st_drop_geometry() %>% 
  # limit to core period with data
  group_by(ID) %>% 
    filter(dt >= 1) %>% # remove duplicate time (just for this stage)
    summarise(n_loc = n(), # number of locations
              p_NA_1m = p_na(first(time), last(time), n_loc, 1),  # 1 min 
              p_NA_2m = p_na(first(time), last(time), n_loc, 2),  # 2 min 
              p_NA_5m = p_na(first(time), last(time), n_loc, 5),  # 5 min 
              p_NA_10m =p_na(first(time), last(time), n_loc, 10),  # 10 min 
              p_NA_20m =p_na(first(time), last(time), n_loc, 20))  # 20 min 
track_summary
```
Here we see that despite the large number of 1 min time steps, at that resolution, >95 /% of the potential locations are missing. Even at the 10 min interval, > 50% of the locations would be missing. Very large data gaps that contribute to much of the missing locations can be excluded from the analysis, therefore, for this tutorial, I will use a 10 min resolution as a compromise between high-resolution information and good temporal coverage.


There are several ways to deal with data gaps, and I will address four 
1. Interpolation (linear or statistical)
2. Multiple imputation
3. Nullification
4. Path segmentation

For large datasets with few and small gaps, the simplest approach to use linear interpolation. First, let's identify thy most likely minute we have data.
```{r identify most freq dt}
# which minute has the most data
tracks_gps %>% 
  st_drop_geometry() %>%  # must convert back to data.frame
  group_by(ID) %>% 
  summarise(minute = str_sub(minute(time),-1)) %>% 
  table()
```
It looks like for all three tracks, the most amount of locations fall on 0 min  (i.e., 10, 20, 30, 40, 50, 60 min). Next, for each track, we will create a vector of times in which to estimate locations.

```{r linear interpolation}
# convert tracks back to data.frame with xy coordinates
tracks_gps_ls <- tracks_gps %>% 
  mutate(x = st_coordinates(tracks_gps)[,"X"],  
         y = st_coordinates(tracks_gps)[,"Y"]) %>%
  st_drop_geometry() %>% 
    split(.,.$ID)  # split into list

# create full time series on which to estimate locations rounded to the nearest 10 min
tracks_gps_ls_time <- tracks_gps %>% 
  st_drop_geometry() %>%  # convert to data.frame
  group_by(ID) %>%
  summarise(time = seq(round_date(first(time), "10 min"), 
                       round_date(last(time), "10 min"),
                       by = 60*10)) %>% 
  split(.,.$ID)  # split into list
```

Now, we can interpolate the locations for each track.

```{r linear interpolation}
# function to create a data frame with approximated locations
approx_locs <- function(tracks, times){
  data.frame(ID = times$ID,
        time = times$time,
        x = approx(tracks$time, tracks$x,
                   xout = times$time)$y,
        y = approx(tracks$time, tracks$y,                               
                   xout = times$time)$y)
}

# Interpolate the location at the times from the sequence
tracks_gps_linear <- mapply(approx_locs, tracks_gps_ls, tracks_gps_ls_time,
                          SIMPLIFY = F) %>% 
  do.call("rbind", .)  # convert list of tracks back to a single data.frame

# remove row names added by rbind
rownames(tracks_gps_linear) <- NULL 

# plot locations
plot(tracks_gps_linear$x, tracks_gps_linear$y, pch = 20, col = "red", xlab = "x", ylab = "y", asp = 1)
points(st_coordinates(tracks_gps)[,"X"], st_coordinates(tracks_gps)[,"Y"], pch = 20)
```
Looks like it works. Let's try fitting an HMM to this. First, lets preparte the data using `prepData` and plot the data to estimate starting parameters.

```{r linear HMM prep}
prep_gps_linear <- prepData(tracks_gps_linear, type = "UTM")

plot(prep_gps_linear, ask = F)
```


```{r linear HMM starting pars}
# Setting up the starting values
mu0 <- c(50, 500) # Mean step length
sigma0 <- c(50, 500) # Sd of the step length
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)
```

Ok, were are ready. Let's fit the HMM

```{r linear HMM fitHMM, message=FALSE}
set.seed(1)
# Fit a 2 state HMM
HMM_gps_linear <- fitHMM(prep_gps_linear, nbState = 2, dist = list(step = "gamma",
angle = "vm"), Par0 = list(step = c(mu0, sigma0), angle = kappa0), formula = ~ 1)

plot(HMM_gps_linear, ask = F)
```

That model does not look good. It's clear from the mapped states that state 1 largely represents the original data, while state 2 primarily represents the interpolated data. This is a common problem when data gaps are frequent or large such that the information in the interpolated data outweighs the signal from the original observations. Generally, I would only use linear interpolation when data gaps are small (< 3 locations) or relatively infrequent (< 20 \% of the modelled locations). In our data, some gaps are > 5 hours (30 locations) and > 50\% of the modelled locations are interpolated. So we need to use another approach.

A slightly better way to interpolate locations is to fit a correlated random walk (CRW) model to the data and predict the most likely locations. `momentuHMM` contains wrapper functions to interpolate missing locations by fitting continuous-time CRW to the data based on the `crawl` package by Devin Johnson and Josh London. There are many options to fit the `crawl` model, and a detailed tutorial for analysis with `crawl` is available here: <https://jmlondon.github.io/crawl-workshop/crawl-practical.html>. Let's try to fit the most basic model using the wrapper function `crawlWrap`.

```{r crawl 10 min gps}
set.seed(1) # crawl often fails, so I recommend always setting a seed 
# fit crawl
crw_gps_10 <- crawlWrap(obsData = tracks_gps, timeStep = "10 mins")
# plot fit tracks
plot(crw_gps_10, ask = F)
```
Notice how the predicted tracks do not make perfectly straight lines through missing sections (particularly noticeable in T172062). Next, we will extract the predicted locations and add them to the observed data.

```{r crawl predict 10 min}
# filter predicted locations, convert CRS, 
tracks_gps_crw <- data.frame(crw_gps_10$crwPredict) %>% 
  filter(locType == "p") %>% 
  dplyr::select(mu.x, mu.y, time,
         ID) %>% 
  dplyr::rename(x = "mu.x", y = "mu.y")
```

Now, let's try to fit the same HMM as before on this data using the same starting parameters.

```{r crawl HMM fitHMM, message = FALSE}
set.seed(1)
# prep data 
prep_gps_crw <- prepData(tracks_gps_crw, type = "UTM")

# Setting up the starting values
mu0 <- c(50, 500) # Mean step length
sigma0 <- c(50, 500) # Sd of the step length
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)

# Fit a 2 state HMM
HMM_gps_crw <- fitHMM(prep_gps_crw, nbState = 2, dist = list(step = "gamma",
    angle = "vm"), Par0 = list(step = c(mu0, sigma0), angle = kappa0))

plot(HMM_gps_crw, ask = F)
```
That's looking much better. It looks like state 1 represents a low-speed, high tortuosity resident state, while state 2 reperesents higher-speed, low tortuosity travelling state. In many instances, this model may be sufficient. However, because we do have such a large amount of interpolated locations, they represent a significant amount of the fitted data and may skew the representation of the states. For example, the large interpolated gaps are still relatively straightened out and a very consistent speed, and may skew the definition of state 2 in particular. There are different ways to deal with this, one of which is to simply keep it in mind when interpreting the results and subsequent analyses. However, here I propose one strategy by nullifying the data streams (i.e., step length and turning angle) during moderate/large interpolated gaps where we expect that the estimated movement has is largely independent of the observed data before or after the gap. The maximum size of a gap to allow depends on the frequency of the missing data, frequency of locations, study species, and behaviours of interest. In this case, I will nullify predicted locations in gaps larger than 60 min. First, we will identify which steps need to be nullified


```{r id nullify gaps}
# identify which data gaps are >=60 min for each track
list_60mim_gps <- lapply(tracks_gps_ls, function(x){
  which(difftime(lead(x$time), x$time, units = "mins")>=60)
})

# create sequence of times for each track from gaps >= 60 min
gap_ls <- mapply(FUN = function(track, gaps){
  # edentify start and end date of each gap
  gaps_ls_SE <- list(start = ceiling_date(track$time[gaps], "10 min"), 
                    end = floor_date(track$time[gaps+1], "10 min"))
  # create sequence by 10 min for each gap
  gaps_ls <- mapply(function(start, end){
    seq(start, end, by = 60*10)}, gaps_ls_SE$start, gaps_ls_SE$end)
  # combine into single vector for each track
  do.call("c", gaps_ls)
  },
  tracks_gps_ls, list_60mim_gps)
```

Next, we will prep the data and nullify the estimated step and angle in gaps >= 60 min.
```{r prep data & nullify gaps}
# prep data and list by ID
prep_gps_crw_NAgaps <- prepData(tracks_gps_crw, type = "UTM") %>% 
  {split(., .$ID)}

# crate function to replace step and turn angle of large gaps with NA
NA_gaps <- function(tracks, times){
  tracks$step[tracks$time %in% times] <- NA
  tracks$angle[tracks$time %in% times] <- NA
  return(tracks)
}

# Interpolate the location at the times from the sequence
prep_tracks_gps_crw_NAgaps <- mapply(FUN = NA_gaps, prep_gps_crw_NAgaps, gap_ls,
                          SIMPLIFY = F) %>% 
  do.call("rbind", .) # convert list of tracks back to a single data.frame
  

```

Now, let's try to fit the same HMM as above to this data with large gaps nullified. 

```{r nullified crawl HMM fitHMM, message = FALSE}
set.seed(1)
# Setting up the starting values
mu0 <- c(50, 500) # Mean step length
sigma0 <- c(50, 500) # Sd of the step length
kappa0 <- c(0.1, 1) # Turning angle concentration parameter (kappa > 0)

# Fit a 2 state HMM
HMM_gps_crw_NAgaps <- fitHMM(prep_tracks_gps_crw_NAgaps, nbState = 2, dist = list(step = "gamma", angle = "vm"), Par0 = list(step = c(mu0, sigma0), angle = kappa0))

plot(HMM_gps_crw_NAgaps, ask = F)
```
Visually, the difference is subtle.

```{r}
HMM_gps_crw$mle[c("step", "angle")]
HMM_gps_crw_NAgaps$mle[c("step", "angle")]
```
The estimated parameters are quite different whether you account for the large gaps in data. When you nullify large gaps, the mean step length for both states is higher, and the turn angle concentration parameters is lower for both states (i.e., more tortuous). The fact that the parameters change for both states, suggests that the large gaps skewed the parameterisation of both states.

Another strategy to deal with larger gaps is to segment the tracks with a new individual ID. This may be particularly appropriate for gaps where we may reasonably expect that the the underlying states are effectively independent of one another. Specifically, we may ask, over what period of time does the behaviour of the animal affect subsequent behaviour. In this case, we may expect that the behaviour of a narwhal depends on the behaviour over the proceeding several hours, however is independent after 24 hours. We can split the tracks for gaps larger than a predetermined threshold by iterating the the ID column. We will not implement this approach in this tutorial, however, it can be done using the following code:

```{r track segmentation}
gap_thresh <- 3*60 # in hours (3h for illustration)
# gaps no more than 6h per segment
new_ID <- (tracks_gps$dt > gap_thresh | tracks_gps$ID != lag(tracks_gps$ID)) %>%  # if dif.time > gap_thresh or new ID
  replace_na(TRUE) %>%  # replace first NA with ID = 1
  cumsum() %>%  # iterate ID 
  paste(tracks_gps$ID, ., sep = "_")
# then smaller gaps <= gap_thresh can be interpolated with crawlWrap
```

## Dealing with location error and irregular time
Thus far, we have been using exclusively the GPS data, which can be assumed to have a negligible error in most applications. However, in many marine systems, we may obtain ARGOS locations, which can have highly variable location error on the order of hundreds of meters to hundreds of km. In addition, ARGOS data often provides location estimates in very irregular time intervals. `crawlWrap` can be used not only to predict impute missing data, but also to predict location when faced with high location error and irregular timeseries. 

location accuracy (ignoring duplicate locations)
```{r}
# identify proportion of each location class
tracks %>% 
  filter(dt > 0) %>% 
  {table(.$loc_class)/nrow(tracks)} 
```

we have to deal with location error, irregular time, and missing locations. we can handle all of these by fitting a 

```{r}
crawlWrap(tracks, timeStep = "10 min")
```

We will provide a prior distribution for each of the location quality classes. The `crawl::crwMLE()` function accepts a function for the ‘prior’ argument. In this example, we provide a normal distribution of the log-transformed error. The standard error of 0.2
```{r message=FALSE}

prior <- function(p) {
  dnorm(p[1], log(50), 0.2, log = TRUE) +  # GPS
  dnorm(p[2], log(250), 0.2, log = TRUE) +  # 3
  dnorm(p[3], log(500), 0.2, log = TRUE) +  # 2
  dnorm(p[4], log(1500), 0.2, log = TRUE) +  # 1
  dnorm(p[5], log(2500), 0.4, log = TRUE) +  # 0
  dnorm(p[6], log(2500), 0.4, log = TRUE) +  # A
  dnorm(p[7], log(2500), 0.4, log = TRUE) +  # B
  # skip p[8] as we won't provide a prior for sigma
  dnorm(p[9], -4, 2, log = TRUE)  # beta parameter 
}

```
In addition to prior distributions for the location quality classes, we can also provide a prior distribution for the beta parameter. We suggest a normal distribution with a mean of -4 and a standard deviation of 2. This encourages the model to fit a smoother track unless the data warrant a rougher, more Brownian, path.

See the crawl tutorial for using fir
```{r message=FALSE}
# # plot with ggplot
# tracks %>% 
#   mutate(x = st_coordinates(tracks)[,"X"],  # convert back to dataframe
#          y = st_coordinates(tracks)[,"Y"]) %>% 
#   ggplot(aes(
#     x = x, y = y, col = factor(id)), stroke = NA) +
#   geom_path()
# explore palettes 
if (require(shiny) && require(shinyjs)) {
     tmaptools::palette_explorer()
}
```


```{r Create a Nested Data Structure, message=FALSE}
## impute missing locations #

# course speed filter
tracks %>% 
  mutate(spd = sqrt(lag()))
# fit crawl model 
crwOut.win1<- crawlWrap(tracks, ncores = ncores, err.model = err.model,Time.name = "date_time",
            prior = prior, predTime = predTimes_2hour, attempts = 150 , retryFits = 30, proj=6103)
crwOut.win1

i <- 2; error <- T
while(error == T){
  tryCatch({
    i <- i+1
    set.seed(i)
    crwOut <- crawlWrap(obsData = pb, timeStep = "4 hours")  #4 hours
    error <- F
  },
  error = function(e){message(paste("On seed number:", i))}
  )
}


```
### Multiple imputation

## Integrating dive data

```{r import depth data, warning=FALSE}
dives <- read.csv("data/dives.csv") %>% 
  mutate(time = ymd_hms(time)) %>% 
  filter(month(time) == 8, day(time) > 7,  day(time) <= 14)

head(dives)
table(dives$dt)
```

It appears as though there are relatively few gaps, however the gaps that exist are relatively long (> 60 mins). Therefore, I suggest that we should regularize and nullify the dive data.

```{r regularise depth data, warning=FALSE}
# regularise data 
dives <- dives %>% 
  group_by(ID) %>%
  # regularise time series by 1.25 min
  summarise(time = seq(first(time), last(time), by = 1.25*60)) %>%
  # merge regularised time with original dive
  left_join(dives, by = c("ID", "time"))
```


Next, we have to summarise the time series into concrete data streams that can be modelled in the HMM. We can use the `diveMove` package to identify individual dives and calculate dive statistics. We must first convert the depth data to the `TDR` class for each whale. As we are working with multiple whales, we will use `lapply` to apply the `createTDR` to each whale -- we will also use `lapply` for most of `diveMove` functions. 

```{r convert depth data to TDR, warning=FALSE}
dives_ls <- split(dives, dives$ID) 
dive_TDR <- lapply(dives_ls, function(data){
  createTDR(time = data$time, depth = data$depth, dtime = 1.25*60, file = "data/dives.csv")
  })

# generate interactive plot
plotTDR(dive_TDR[[1]]) # note: try zooming in to part of the dive
```

Next, we must use the `calibrateDepth` to calibrate the depth data. This function identifies wet and dry periods (for animals that haul out), applies a zero-offset correction (ZOC), and identifies all dives in the record and their phases. ZOC can be done using either the `offset` or `filter` method. In this case, we will assume the depth data is accurate and does not require an offset. We should also specify `dive.thr`, which represents the threshold depth below which an underwater phase should be considered a dive -- in this case, we will set it at 8 m. There are many other optional parameters to identify dives that we will not get into in this tutorial (See `vignette("diveMove")` for details). 

```{r calibrate TDR, warning=FALSE}
# calibrate TDR and identify dive phases
dive_TDR_calib <- lapply(X = dive_TDR, FUN = calibrateDepth, zoc.method = "offset", offset = 0, dive.thr = 8)

# interactive plot of calibrated DTR
plotTDR(dive_TDR_calib[[1]], surface = T)
```
In the interactive plot, try zooming into one of the dives and hover mouse over plot to preview the phases identified by `calibrateDepth'. The phases identified correspond to descent (D), descent/bottom (DB), bottom (B), bottom/ascent (BA), ascent (A), and surface (X). We can plot a specific dives as follows:
```{r plot TDR_calib dives}
plotTDR(dive_TDR_calib[[1]], diveNo = 1:300, surface = T)
```
Now, we can calculate summary statistics for each dive using the function `diveStats`. There are many dive metrics that are estimated, and which ones to retain are species, data, and question specific. In this case, we will retain 8 from those calculated by `diveStats`: dive time, bottom time,  maximum depth, bottom distance (measure of "wiggling while at the bottom), post-dive duration.

```{r calc summary dive stats}
# calculate dive stats and add dive.id to each dive 
dive_sum <- lapply(dive_TDR_calib, function(data){
  mutate(diveStats(data, depth.deriv = F), dive.id = row_number()) %>% 
    dplyr::select(dive.id, divetim, botttim, maxdep, bottdist, postdive.dur)}) # select variables of interest

# add dive.id with depth data to each depth record
dives_ls <- mapply(function(TDR, dives){
  mutate(TDR, dive.id = dives@dive.activity$dive.id)
  }, TDR = dives_ls, dives = dive_TDR_calib, SIMPLIFY = F)

# join TDR data with dive summary data
dives_ls <- mapply(function(TDR, dive_sum){
  left_join(TDR, dive_sum, by = "dive.id")
  }, TDR = dives_ls, dive_sum = dive_sum, SIMPLIFY = F)

# convert dive_ls back to a data.frame
dives_df <- do.call(rbind, dives_ls)
```
Next, we will replace any bottom time of a valid dive (dive.id > 0) to 75 s, since at least some time must be spent at the bottom. Then, we will calculate one additional metric as a proxy for dive shape; the ratio of bottom time to dive time. Dives where $\leq20\%$ of the time is spent at the bottom represent V-shaped dives, U-shaped dives are represented when $>20$ and $\leq50\%$ is spent at the bottom, and square dives are represented when $>50\%$ of the time is spent at the bottom. 
```{r calc percent bottom}
# replace NA bottom time of valid dives
dives_df$botttim[dives_df$dive.id > 0 & is.na(dives_df$botttim)] <- 75
# calculate proportion time at bottom
dives_df <- dives_df %>% 
  mutate(propbott = botttim/divetim)
# remove "dives" with no duration
dives_df <- dives_df %>% 
  filter(!(dive.id > 0 & is.na(divetim)))
```
The next issue is that the dive data is at a different temporal resolution (75 s) than the location data (10 min). There are two options to include both data streams in the same HMM. First, we can choose to implement a hierarchical HMM, however, this is more complicated, and  will be covered in tomorrow's tutorial. The second, which we will use here, is to summarise the depth/dive data to a 10 min resolution and include them as additional data streams with step length and turning angle. 
```{r summarise dive data to 10 min}
dives_sum <- dives_df %>% 
  # round time to same interval as location data
  mutate(time = floor_date(time, "10 min")) %>% 
  # group rows by time interval
  group_by(ID, time) %>% 
  # summarise data
  summarise(NA_t          = sum(is.na(depth))*1.25,
            surf_t        = sum(dive.id == 0)*1.25,
            mean_dep      = ifelse(NA_t == 10, NA, mean(na.rm = T, depth)),
            max_dep       = ifelse(NA_t == 10, NA, max(na.rm = T, depth)),
            dive_t        = ifelse(NA_t == 10, NA, sum(na.rm = T, divetim)),
            bott_t        = ifelse(dive_t < 5, NA, sum(na.rm = T, botttim)),
            prop_bott     = ifelse(dive_t < 5, NA, max(na.rm = T, propbott)),
            max_dive_dep  = ifelse(dive_t < 5, NA, max(na.rm = T, maxdep)),
            bott_dist     = ifelse(dive_t < 5, NA, max(na.rm = T, bottdist)),
            post_dive_dur = ifelse(dive_t < 5, NA, max(na.rm = T, postdive.dur))) %>% 
  # remove -Inf values (typically error)
  filter(!is.infinite(dive_t) & !is.infinite(bott_dist))

# preview
head(dives_sum)
```
Note, we used 2 different `ifelse` statements. First, `ifelse(NA_t == 10, ...)` ensured that we only calculate mean and maximum depth for periods where we have at least 1.25 min of depth data. Second, `ifelse(surf_t > 5, ...)` ensured that we only calculate dive metrics when at least half of the 10 min interval is spent in a dive, otherwise the animal is assumed to be at the surface and its dive metric is `NA`.

Any of the eight variables can be used as data streams in the HMM, however, including too many would significantly increase the number of parameters to estimate, and consequently computation time. Therefore, we must select which variables to use, which there are different several approaches:
1. Variable can be selected using expert on the species behaviour and research question.
2. We preferably want to avoid variable with a lot of missing data. 
3. The data streams should exhibit variation and evidence of clustering or multi-modality that may be tied to the underlying behaviours. 
4. Data streams with no variation or conversely are very noisy contain little information on underlying behaviour.
5. We want to avoid variables that are overdispersed and which would be difficult to describe using a statistical distribution. 
6. Given that they are tied to autocorrelated behaviours, they too should exhibit some -- but not too much -- autocorrelation. 
7. One of HMM's key assumptions that the data stream are be independent of each other, therefore, we should avoid select highly co-linear data streams. 

Assuming all the variables are biologically relevant, let's look at structure in the data.
I will also add a subjective score based on the results (first number after `#` symbol).

```{r data structure}
vars <- c("mean_dep","max_dep","dive_t","bott_t","prop_bott",
          "max_dive_dep","bott_dist","post_dive_dur")
# First, missing data
dives_sum %>% 
  summarise(mean_dep      = sum(is.na(mean_dep)),      # 2
            max_dep       = sum(is.na(max_dep)),       # 2
            dive_t        = sum(is.na(dive_t)),        # 2
            bott_t        = sum(is.na(bott_t)),        # 1
            prop_bott     = sum(is.na(prop_bott)),     # 1
            max_dive_dep  = sum(is.na(max_dive_dep)),  # 1
            bott_dist     = sum(is.na(bott_dist)),     # 1
            post_dive_dur = sum(is.na(post_dive_dur))) # 1

# Second, evidence of multi-modality, balanced variation, and no over-dispersion
# as the dive variables are zero-bound, applying a log transformation makes it easier to see structure in the distirbution 
# dives_sum %>% 
#   ungroup() %>% 
#   dplyr::select(vars) %>% 
#   apply(2, hist, 100)
hist(log(dives_sum$mean_dep), 100)      # 2 good structure, high dispersion
hist(log(dives_sum$max_dep), 100)       # 3 great structure, moderate dispersion
hist(log(dives_sum$dive_t), 100)        # 1 little structure, fragmented distribution
hist(log(dives_sum$bott_t), 100)        # 0 little structure, fragmented distribution
hist(logit(dives_sum$prop_bott), 100)   # 0 no structure, fragmented distribution
hist(log(dives_sum$max_dive_dep), 100)  # 2 good structure, low dispersion
hist(log(dives_sum$bott_dist), 100)     # 2 moderate structure, high dispersion
hist(log(dives_sum$post_dive_dur), 100) # 0 little structure, high dispersion

# Third, balanced autocorrelation
dives_sum_filter <- filter(dives_sum, ID == 172062)
acf(dives_sum_filter$mean_dep, na.action = na.pass)       # 1 ACF~8 some variability
acf(dives_sum_filter$max_dep, na.action = na.pass)        # 2 ACF~8 gradual decline
acf(dives_sum_filter$dive_t, na.action = na.pass)         # 2 ACF~7 gradual decline
acf(dives_sum_filter$bott_t, na.action = na.pass)         # 0 ACF~3
acf(dives_sum_filter$prop_bott, na.action = na.pass)      # 0 ACF~2
acf(dives_sum_filter$max_dive_dep, na.action = na.pass)   # 1 gradual but high ACF~22
acf(dives_sum_filter$bott_dist, na.action = na.pass)      # 1 low ACF~4
acf(dives_sum_filter$post_dive_dur, na.action = na.pass)  # 0 low ACF~1

# subjective score
data.frame(var = c("mean_dep", "max_dep", "dive_t", "bott_t", "prop_bott", 
                   "max_dive_dep", "bott_dist", "post_dive_dur"),
           score = c(5, 6, 5, 1, 
                     1, 4, 4, 1))

```
From my subjective interpretation of these outputs, I think the five most promising variables to include are maximum depth, dive time, mean depth, maximum dive depth, and bottom distribution. Next, let's merge the dive data streams the location data.

```{r merge track & dive data.}
tracks_dives <- left_join(prep_tracks_gps_crw_NAgaps, 
                          dives_sum[,c("ID", "time", "max_dep", "dive_t", 
                                       "mean_dep", "max_dive_dep", "bott_dist")], 
                          by = c("ID", "time"))
```

Now, we must check for co-linearity between the data streams to select 1--3 to use in the HMM. We can check co-linearity using the Paerson's correlation matrix.

```{r dive co-linearity}
# calculate and plot check Paerson's correlation matrix
tracks_dives[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", 
             "bott_dist", "step", "angle")] %>% 
  na.omit() %>%
  cor() %>% 
  corrplot(method="number")
```
`step` and `angle` seem quit independent from all variables as does `bott_dist`. Unfortunately, there is quite high correlation between the first four dive data streams, se we will have to select which to use. `dive_t` and `mean_dep` have the lowest correlation with `bott_dist` and `step`, however `max_dep` had the highest subjective score. For the purposes of this tutorial, I will use `max_dep` and `bott_dist`. 

To get starting parameters, we can fit an HMM to each one independently. We will use the gamma distribution for both and for now will use the same starting parameters.
```{r}
# identify whether there is 0 data
tracks_dives %>% 
  summarise(max_dep = sum(max_dep == 0, na.rm = T), 
            bott_dist = sum(bott_dist == 0, na.rm = T)) 
# therefore, we need to include zero-mass parameters for bott_dist

# starting parameters (will use same ones for both for now)
mu0 <- c(130, 180)  # mean
sigma0 <- c(60, 90)  # sd
zm <- c(0.1, 0.1)  # zero mass, where applicable

# fit dive-only HMMs
set.seed(1)
HMM_max_dep <- fitHMM(tracks_dives, nbStates = 2, dist = list(max_dep = "gamma"), 
                      Par0 = list(max_dep = c(mu0, sigma0)), retryFits = 5)
HMM_bott_dist <- fitHMM(tracks_dives, nbStates = 2, dist = list(bott_dist = "gamma"), 
                        Par0 = list(bott_dist = c(mu0, sigma0, zm)), retryFits = 5)
```
Next, we can integrate these into one HMM together


One additional option to select which dive data stream to use, is to  and examine which performs better. All of dive data streams are zero-bound, therefore, we can the gamma, log normal, or Weibull distrutions to describe them. For simplicity, we will use the gamma for all, and also divide each data stream by its respective standard deviation to standardise them. 

```{r prep dive data and independent HMMs, message=FALSE}
# standardise dive variables (not necessary)
tracks_dives_prep <- tracks_dives %>% 
  mutate(max_dep = max_dep/sd(max_dep, na.rm = T), 
         dive_t = dive_t/sd(dive_t, na.rm = T), 
         mean_dep = mean_dep/sd(mean_dep, na.rm = T), 
         max_dive_dep = max_dive_dep/sd(max_dive_dep, na.rm = T), 
         bott_dist = bott_dist/sd(bott_dist, na.rm = T)) 

# identify whether there is 0 data
tracks_dives %>% 
  summarise(max_dep = sum(max_dep==0, na.rm = T), 
            dive_t = sum(dive_t==0, na.rm = T), 
            mean_dep = sum(mean_dep==0, na.rm = T), 
            max_dive_dep = sum(max_dive_dep==0, na.rm = T), 
            bott_dist = sum(bott_dist==0, na.rm = T)) 
# therefore, we need to include zero-mass parameters for dive_t and bott_dist

# fit dive-only HMMs
set.seed(1)
HMM_max_dep <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(max_dep="gamma"), 
                      Par0 = list(max_dep = c(mu0, sigma0)))
HMM_dive_t <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(dive_t="gamma"), 
                     Par0 = list(dive_t = c(mu0, sigma0, zm)))
HMM_mean_dep <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(mean_dep="gamma"), 
                       Par0 = list(mean_dep = c(mu0, sigma0)))
HMM_max_dive_dep <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(max_dive_dep="gamma"),
                           Par0 = list(max_dive_dep = c(mu0, sigma0)))
HMM_bott_dist <- fitHMM(tracks_dives_prep, nbStates=2, dist=list(bott_dist="gamma"), 
                        Par0 = list(bott_dist = c(mu0, sigma0, zm)))
```
Now, to compare the models, we cannot use standard metrics of AIC, likelihood, or r$^2$ since the response data (the dive variables) are all different. However, we can look at metrics of 
```{r compare dive-only HMMs, message=FALSE}
plotPR(HMM_max_dep)
plotPR(HMM_dive_t)
plotPR(HMM_mean_dep)
plotPR(HMM_max_dive_dep)
plotPR(HMM_bott_dist)

plot(HMM_max_dep, ask = F)
plot(HMM_dive_t, ask = F)
plot(HMM_mean_dep, ask = T)
plot(HMM_max_dive_dep, ask = T)
plot(HMM_bott_dist, ask = F)
plot(HMM_gps_crw_NAgaps, ask = F)

filter(tracks_dives_prep, ID == "T172062") %>% 
  ggplot(aes(x = x, y = y, col = mean_dep)) + 
  geom_point() + theme_classic()  # 1
filter(tracks_dives_prep, ID == "T172062") %>% 
  ggplot(aes(x = x, y = y, col = max_dep)) + 
  geom_point() + theme_classic()  # 1
filter(tracks_dives_prep, ID == "T172062") %>% 
  ggplot(aes(x = x, y = y, col = dive_t)) + 
  geom_point() + theme_classic() #  1
filter(tracks_dives_prep, ID == "T172062") %>% 
  ggplot(aes(x = x, y = y, col = max_dive_dep)) + 
  geom_point() + theme_classic() # 
filter(tracks_dives_prep, ID == "T172062") %>% 
  ggplot(aes(x = x, y = y, col = bott_dist)) + 
  geom_point() + theme_classic() # 


AIC(HMM_max_dep, HMM_dive_t, HMM_mean_dep, HMM_max_dive_dep, HMM_bott_dist)

f <- which(!is.na(prep_tracks_gps_crw_NAgaps$step))
states_sa <- viterbi(HMM_gps_crw_NAgaps)[f]

data.frame(max_dep = sum(viterbi(HMM_max_dep)[f]==states_sa),
           dive_t = sum(viterbi(HMM_dive_t)[f]==states_sa),
           mean_dep = sum(viterbi(HMM_mean_dep)[f]==states_sa),
           max_dive_dep = sum(viterbi(HMM_max_dive_dep)[f]==states_sa),
           bott_dist = sum(viterbi(HMM_bott_dist)[f]==states_sa))


library(psych)

pairs.panels(tracks_dives_prep[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", 
             "bott_dist", "step", "angle")],
             gap = 0,
             pch=21)
# PCA
dat <- tracks_dives_prep %>% 
  mutate(mean_dep = log(mean_dep),
         max_dep = log(max_dep),
         dive_t = log(dive_t),
         bott_t = log(bott_t),
         prop_bott = logit(prop_bott),
         max_dive_dep = log(max_dive_dep),
         bott_dist = log(bott_dist),
         post_dive_dur = log(post_dive_dur),
         state = viterbi(HMM_gps_crw_NAgaps)) %>% 
  dplyr::select(max_dep, dive_t, mean_dep, max_dive_dep, bott_dist, step, angle) %>% 
  na.omit() %>% 
  {.[!is.infinite(rowSums(.)),]}

pairs.panels(dat,
             gap = 0,
             pch=21)
dat %>% 
cor() %>% 
  corrplot(method="number")

tracks_dives[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", 
             "bott_dist", "step", "angle")] %>% 
  na.omit() %>% {.[!is.infinite(rowSums(.)),]} %>% nrow()

pc <- prcomp(na.omit(dat[!is.infinite(rowSums(dat[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", "bott_dist", "step", "angle")])),
                         c("max_dep", "dive_t", "mean_dep", "max_dive_dep", "bott_dist", "step", "angle")]),
             center = TRUE,
            scale. = TRUE)
attributes(pc)
print(pc)
library(factoextra)
fviz_eig(pc)
groups <- as.factor(na.omit(dat[!is.infinite(rowSums(dat[,c("max_dep", "dive_t", "mean_dep", "max_dive_dep", "bott_dist", "step", "angle")])),])[,"state"])
fviz_pca_ind(pc,
             col.ind = groups, # color by groups
             palette = c("#00AFBB",  "#FC4E07"),
             addEllipses = TRUE, # Concentration ellipses
             ellipse.type = "confidence",
             legend.title = "Groups",
             repel = TRUE
             )

library(ggfortify)
df <- iris[1:4]
pca_res <- prcomp(df, scale. = TRUE)

autoplot(pca_res)
```








```{r calibrate TDR, warning=FALSE}
i = 0
plot(dives$depth*-1, pch = 19, type = 'l', xlim = c(1,8)+8*i, ylim = c(-100,0)); i = i+1
i = 0
plot(dives$dt, pch = 19, xlim = c(1,100)+100*i); i = i+1
# regularise dive
hist(dives$depth,2000, xlim = c(0,200))




# round time to nearest 10 min
# summarise 
## max depth
## mean depth
## 3rd quantile of depth 
## number of dives
## number small vs short dives 
## time at depth
## percent to bottom
## depth variance
## dive type (which dive is most )
# method of summary strongly depends on resolution of HMM. in some cases, individual dives can last longer than the HMM step, and depending on when within the 10 min step a dive starts, we may capture the entirety or just a portion of the dive (e.g., ascent, and descent). Conversely, with lower time locations, we may have a number of dives in each step that must be summarised (e.g., number of dives)

library(terra)
bath <- rast("data/gebco_2022_n74.0_s71.5_w-82.0_e-77.0.tif") %>% 
  crop(ext(-82, -76, 72, 73))





```

```{r plot all tracks}
# convert to lines and plot using tmap
tracks %>% group_by(ID) %>% 
  summarise(do_union = F) %>% 
  st_cast("LINESTRING") %>% 
     tm_shape() +
   tm_lines(col = "ID", palette = "Dark2")

```

```{r}
# first passage time
tracks_high <- filter(tracks, loc_class %in% c("GPS", 3, 2, 1))
ltraj <- as.ltraj(xy = cbind(st_coordinates(tracks_high)[,"X"],
                             st_coordinates(tracks_high)[,"Y"]),
                  date = tracks_high$time, id=factor(tracks_high$ID))
fpt_low <- fpt(ltraj, seq(100, 3000, length=100), units = "hours") %>% 
  varlogfpt() 
fpt_med <- fpt(ltraj, seq(3000, 20000, length=200), units = "hours") %>% 
  varlogfpt()
fpt_hig <- fpt(ltraj, seq(20000, 100000, length=200), units = "hours") %>% 
  varlogfpt()
fpt(ltraj, 1500, units = "hours") %>% unlist %>% mean(na.rm = T)/40
fpt(ltraj, 15000, units = "hours") %>% unlist %>% mean(na.rm = T)/40
fpt(ltraj, 40000, units = "hours") %>% unlist %>% mean(na.rm = T)/40
# looks like there are are increases/plateaus of variance at around 1.5, 15, 40, & 80 km
```

